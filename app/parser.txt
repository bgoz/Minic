Grammar:

Rule 0     S' -> program
Rule 1     program -> decl_list
Rule 2     decl_list -> decl
Rule 3     decl_list -> decl_list decl
Rule 4     decl -> const_decl
Rule 5     decl -> fun_decl
Rule 6     decl -> var_decl
Rule 7     const_decl -> CONST IDENT = expr ;  [precedence=left, level=9]
Rule 8     var_decl -> type_spec IDENT [ expr ] ;  [precedence=left, level=9]
Rule 9     var_decl -> type_spec IDENT = expr ;  [precedence=left, level=9]
Rule 10    var_decl -> type_spec IDENT ;  [precedence=left, level=9]
Rule 11    type_spec -> CHAR
Rule 12    type_spec -> BOOL
Rule 13    type_spec -> FLOAT
Rule 14    type_spec -> INT
Rule 15    type_spec -> VOID
Rule 16    fun_decl -> type_spec IDENT ( params ) compound_stmt  [precedence=left, level=9]
Rule 17    params -> VOID
Rule 18    params -> param_list
Rule 19    param_list -> param
Rule 20    param_list -> param_list , param  [precedence=right, level=10]
Rule 21    param -> type_spec IDENT [ ]  [precedence=left, level=9]
Rule 22    param -> type_spec IDENT
Rule 23    compound_stmt -> { local_decls stmt_list }  [precedence=left, level=9]
Rule 24    local_decls -> empty
Rule 25    local_decls -> local_decls local_decl
Rule 26    local_decl -> type_spec IDENT = expr ;  [precedence=left, level=9]
Rule 27    local_decl -> type_spec IDENT [ expr ] ;  [precedence=left, level=9]
Rule 28    local_decl -> type_spec IDENT ;  [precedence=left, level=9]
Rule 29    stmt_list -> empty
Rule 30    stmt_list -> stmt_list stmt
Rule 31    stmt -> break_stmt
Rule 32    stmt -> return_stmt
Rule 33    stmt -> while_stmt
Rule 34    stmt -> if_stmt
Rule 35    stmt -> compound_stmt
Rule 36    stmt -> expr_stmt
Rule 37    expr_stmt -> ;  [precedence=left, level=9]
Rule 38    expr_stmt -> expr ;  [precedence=left, level=9]
Rule 39    while_stmt -> WHILE ( expr ) stmt  [precedence=left, level=9]
Rule 40    if_stmt -> IF ( expr ) stmt ELSE stmt  [precedence=left, level=1]
Rule 41    if_stmt -> IF ( expr ) stmt  [precedence=left, level=9]
Rule 42    return_stmt -> RETURN expr ;  [precedence=left, level=9]
Rule 43    return_stmt -> RETURN ;  [precedence=left, level=9]
Rule 44    break_stmt -> BREAK
Rule 45    location -> IDENT [ expr ]  [precedence=left, level=9]
Rule 46    location -> IDENT
Rule 47    expr -> - expr  [precedence=right, level=10]
Rule 48    expr -> + expr  [precedence=right, level=10]
Rule 49    expr -> NEW type_spec [ expr ]  [precedence=left, level=9]
Rule 50    expr -> CHAR_LIT
Rule 51    expr -> FLOAT_LIT
Rule 52    expr -> INT_LIT
Rule 53    expr -> BOOL_LIT
Rule 54    expr -> IDENT . SIZE
Rule 55    expr -> IDENT ( args )  [precedence=left, level=9]
Rule 56    expr -> CONST
Rule 57    expr -> location
Rule 58    expr -> ( expr )  [precedence=left, level=9]
Rule 59    expr -> ! expr  [precedence=right, level=10]
Rule 60    expr -> expr % expr  [precedence=left, level=8]
Rule 61    expr -> expr / expr  [precedence=left, level=8]
Rule 62    expr -> expr * expr  [precedence=left, level=8]
Rule 63    expr -> expr - expr  [precedence=left, level=7]
Rule 64    expr -> expr + expr  [precedence=left, level=7]
Rule 65    expr -> expr > expr  [precedence=left, level=6]
Rule 66    expr -> expr GE expr  [precedence=left, level=6]
Rule 67    expr -> expr < expr  [precedence=left, level=6]
Rule 68    expr -> expr LE expr  [precedence=left, level=6]
Rule 69    expr -> expr NE expr  [precedence=left, level=5]
Rule 70    expr -> expr EQ expr  [precedence=left, level=5]
Rule 71    expr -> expr AND expr  [precedence=left, level=4]
Rule 72    expr -> expr OR expr  [precedence=left, level=3]
Rule 73    expr -> location = expr  [precedence=right, level=2]
Rule 74    arg_list -> expr
Rule 75    arg_list -> arg_list , expr  [precedence=right, level=10]
Rule 76    args -> empty
Rule 77    args -> arg_list
Rule 78    empty -> <empty>

Unused terminals:

    FALSE
    TRUE

Terminals, with rules where they appear:

!                    : 59
%                    : 60
(                    : 16 39 40 41 55 58
)                    : 16 39 40 41 55 58
*                    : 62
+                    : 48 64
,                    : 20 75
-                    : 47 63
.                    : 54
/                    : 61
;                    : 7 8 9 10 26 27 28 37 38 42 43
<                    : 67
=                    : 7 9 26 73
>                    : 65
AND                  : 71
BOOL                 : 12
BOOL_LIT             : 53
BREAK                : 44
CHAR                 : 11
CHAR_LIT             : 50
CONST                : 7 56
ELSE                 : 40
EQ                   : 70
FALSE                : 
FLOAT                : 13
FLOAT_LIT            : 51
GE                   : 66
IDENT                : 7 8 9 10 16 21 22 26 27 28 45 46 54 55
IF                   : 40 41
INT                  : 14
INT_LIT              : 52
LE                   : 68
NE                   : 69
NEW                  : 49
OR                   : 72
RETURN               : 42 43
SIZE                 : 54
TRUE                 : 
VOID                 : 15 17
WHILE                : 39
[                    : 8 21 27 45 49
]                    : 8 21 27 45 49
error                : 
{                    : 23
}                    : 23

Nonterminals, with rules where they appear:

arg_list             : 75 77
args                 : 55
break_stmt           : 31
compound_stmt        : 16 35
const_decl           : 4
decl                 : 2 3
decl_list            : 1 3
empty                : 24 29 76
expr                 : 7 8 9 26 27 38 39 40 41 42 45 47 48 49 58 59 60 60 61 61 62 62 63 63 64 64 65 65 66 66 67 67 68 68 69 69 70 70 71 71 72 72 73 74 75
expr_stmt            : 36
fun_decl             : 5
if_stmt              : 34
local_decl           : 25
local_decls          : 23 25
location             : 57 73
param                : 19 20
param_list           : 18 20
params               : 16
program              : 0
return_stmt          : 32
stmt                 : 30 39 40 40 41
stmt_list            : 23 30
type_spec            : 8 9 10 16 21 22 26 27 28 49
var_decl             : 6
while_stmt           : 33


state 0

    (0) S' -> . program
    (1) program -> . decl_list
    (2) decl_list -> . decl
    (3) decl_list -> . decl_list decl
    (4) decl -> . const_decl
    (5) decl -> . fun_decl
    (6) decl -> . var_decl
    (7) const_decl -> . CONST IDENT = expr ;
    (16) fun_decl -> . type_spec IDENT ( params ) compound_stmt
    (8) var_decl -> . type_spec IDENT [ expr ] ;
    (9) var_decl -> . type_spec IDENT = expr ;
    (10) var_decl -> . type_spec IDENT ;
    (11) type_spec -> . CHAR
    (12) type_spec -> . BOOL
    (13) type_spec -> . FLOAT
    (14) type_spec -> . INT
    (15) type_spec -> . VOID
    CONST           shift and go to state 7
    CHAR            shift and go to state 9
    BOOL            shift and go to state 10
    FLOAT           shift and go to state 11
    INT             shift and go to state 12
    VOID            shift and go to state 13

    program                        shift and go to state 1
    decl_list                      shift and go to state 2
    decl                           shift and go to state 3
    const_decl                     shift and go to state 4
    fun_decl                       shift and go to state 5
    var_decl                       shift and go to state 6
    type_spec                      shift and go to state 8

state 1

    (0) S' -> program .


state 2

    (1) program -> decl_list .
    (3) decl_list -> decl_list . decl
    (4) decl -> . const_decl
    (5) decl -> . fun_decl
    (6) decl -> . var_decl
    (7) const_decl -> . CONST IDENT = expr ;
    (16) fun_decl -> . type_spec IDENT ( params ) compound_stmt
    (8) var_decl -> . type_spec IDENT [ expr ] ;
    (9) var_decl -> . type_spec IDENT = expr ;
    (10) var_decl -> . type_spec IDENT ;
    (11) type_spec -> . CHAR
    (12) type_spec -> . BOOL
    (13) type_spec -> . FLOAT
    (14) type_spec -> . INT
    (15) type_spec -> . VOID
    $end            reduce using rule 1 (program -> decl_list .)
    CONST           shift and go to state 7
    CHAR            shift and go to state 9
    BOOL            shift and go to state 10
    FLOAT           shift and go to state 11
    INT             shift and go to state 12
    VOID            shift and go to state 13

    decl                           shift and go to state 14
    const_decl                     shift and go to state 4
    fun_decl                       shift and go to state 5
    var_decl                       shift and go to state 6
    type_spec                      shift and go to state 8

state 3

    (2) decl_list -> decl .
    CONST           reduce using rule 2 (decl_list -> decl .)
    CHAR            reduce using rule 2 (decl_list -> decl .)
    BOOL            reduce using rule 2 (decl_list -> decl .)
    FLOAT           reduce using rule 2 (decl_list -> decl .)
    INT             reduce using rule 2 (decl_list -> decl .)
    VOID            reduce using rule 2 (decl_list -> decl .)
    $end            reduce using rule 2 (decl_list -> decl .)


state 4

    (4) decl -> const_decl .
    CONST           reduce using rule 4 (decl -> const_decl .)
    CHAR            reduce using rule 4 (decl -> const_decl .)
    BOOL            reduce using rule 4 (decl -> const_decl .)
    FLOAT           reduce using rule 4 (decl -> const_decl .)
    INT             reduce using rule 4 (decl -> const_decl .)
    VOID            reduce using rule 4 (decl -> const_decl .)
    $end            reduce using rule 4 (decl -> const_decl .)


state 5

    (5) decl -> fun_decl .
    CONST           reduce using rule 5 (decl -> fun_decl .)
    CHAR            reduce using rule 5 (decl -> fun_decl .)
    BOOL            reduce using rule 5 (decl -> fun_decl .)
    FLOAT           reduce using rule 5 (decl -> fun_decl .)
    INT             reduce using rule 5 (decl -> fun_decl .)
    VOID            reduce using rule 5 (decl -> fun_decl .)
    $end            reduce using rule 5 (decl -> fun_decl .)


state 6

    (6) decl -> var_decl .
    CONST           reduce using rule 6 (decl -> var_decl .)
    CHAR            reduce using rule 6 (decl -> var_decl .)
    BOOL            reduce using rule 6 (decl -> var_decl .)
    FLOAT           reduce using rule 6 (decl -> var_decl .)
    INT             reduce using rule 6 (decl -> var_decl .)
    VOID            reduce using rule 6 (decl -> var_decl .)
    $end            reduce using rule 6 (decl -> var_decl .)


state 7

    (7) const_decl -> CONST . IDENT = expr ;
    IDENT           shift and go to state 15


state 8

    (16) fun_decl -> type_spec . IDENT ( params ) compound_stmt
    (8) var_decl -> type_spec . IDENT [ expr ] ;
    (9) var_decl -> type_spec . IDENT = expr ;
    (10) var_decl -> type_spec . IDENT ;
    IDENT           shift and go to state 16


state 9

    (11) type_spec -> CHAR .
    IDENT           reduce using rule 11 (type_spec -> CHAR .)
    [               reduce using rule 11 (type_spec -> CHAR .)


state 10

    (12) type_spec -> BOOL .
    IDENT           reduce using rule 12 (type_spec -> BOOL .)
    [               reduce using rule 12 (type_spec -> BOOL .)


state 11

    (13) type_spec -> FLOAT .
    IDENT           reduce using rule 13 (type_spec -> FLOAT .)
    [               reduce using rule 13 (type_spec -> FLOAT .)


state 12

    (14) type_spec -> INT .
    IDENT           reduce using rule 14 (type_spec -> INT .)
    [               reduce using rule 14 (type_spec -> INT .)


state 13

    (15) type_spec -> VOID .
    IDENT           reduce using rule 15 (type_spec -> VOID .)
    [               reduce using rule 15 (type_spec -> VOID .)


state 14

    (3) decl_list -> decl_list decl .
    CONST           reduce using rule 3 (decl_list -> decl_list decl .)
    CHAR            reduce using rule 3 (decl_list -> decl_list decl .)
    BOOL            reduce using rule 3 (decl_list -> decl_list decl .)
    FLOAT           reduce using rule 3 (decl_list -> decl_list decl .)
    INT             reduce using rule 3 (decl_list -> decl_list decl .)
    VOID            reduce using rule 3 (decl_list -> decl_list decl .)
    $end            reduce using rule 3 (decl_list -> decl_list decl .)


state 15

    (7) const_decl -> CONST IDENT . = expr ;
    =               shift and go to state 17


state 16

    (16) fun_decl -> type_spec IDENT . ( params ) compound_stmt
    (8) var_decl -> type_spec IDENT . [ expr ] ;
    (9) var_decl -> type_spec IDENT . = expr ;
    (10) var_decl -> type_spec IDENT . ;
    (               shift and go to state 18
    [               shift and go to state 19
    =               shift and go to state 21
    ;               shift and go to state 20


state 17

    (7) const_decl -> CONST IDENT = . expr ;
    (47) expr -> . - expr
    (48) expr -> . + expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . CHAR_LIT
    (51) expr -> . FLOAT_LIT
    (52) expr -> . INT_LIT
    (53) expr -> . BOOL_LIT
    (54) expr -> . IDENT . SIZE
    (55) expr -> . IDENT ( args )
    (56) expr -> . CONST
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . ! expr
    (60) expr -> . expr % expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (65) expr -> . expr > expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr < expr
    (68) expr -> . expr LE expr
    (69) expr -> . expr NE expr
    (70) expr -> . expr EQ expr
    (71) expr -> . expr AND expr
    (72) expr -> . expr OR expr
    (73) expr -> . location = expr
    (45) location -> . IDENT [ expr ]
    (46) location -> . IDENT
    -               shift and go to state 25
    +               shift and go to state 26
    NEW             shift and go to state 27
    CHAR_LIT        shift and go to state 28
    FLOAT_LIT       shift and go to state 29
    INT_LIT         shift and go to state 30
    BOOL_LIT        shift and go to state 31
    IDENT           shift and go to state 23
    CONST           shift and go to state 22
    (               shift and go to state 32
    !               shift and go to state 34

    expr                           shift and go to state 24
    location                       shift and go to state 33

state 18

    (16) fun_decl -> type_spec IDENT ( . params ) compound_stmt
    (17) params -> . VOID
    (18) params -> . param_list
    (19) param_list -> . param
    (20) param_list -> . param_list , param
    (21) param -> . type_spec IDENT [ ]
    (22) param -> . type_spec IDENT
    (11) type_spec -> . CHAR
    (12) type_spec -> . BOOL
    (13) type_spec -> . FLOAT
    (14) type_spec -> . INT
    (15) type_spec -> . VOID
    VOID            shift and go to state 37
    CHAR            shift and go to state 9
    BOOL            shift and go to state 10
    FLOAT           shift and go to state 11
    INT             shift and go to state 12

    type_spec                      shift and go to state 35
    params                         shift and go to state 36
    param_list                     shift and go to state 38
    param                          shift and go to state 39

state 19

    (8) var_decl -> type_spec IDENT [ . expr ] ;
    (47) expr -> . - expr
    (48) expr -> . + expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . CHAR_LIT
    (51) expr -> . FLOAT_LIT
    (52) expr -> . INT_LIT
    (53) expr -> . BOOL_LIT
    (54) expr -> . IDENT . SIZE
    (55) expr -> . IDENT ( args )
    (56) expr -> . CONST
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . ! expr
    (60) expr -> . expr % expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (65) expr -> . expr > expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr < expr
    (68) expr -> . expr LE expr
    (69) expr -> . expr NE expr
    (70) expr -> . expr EQ expr
    (71) expr -> . expr AND expr
    (72) expr -> . expr OR expr
    (73) expr -> . location = expr
    (45) location -> . IDENT [ expr ]
    (46) location -> . IDENT
    -               shift and go to state 25
    +               shift and go to state 26
    NEW             shift and go to state 27
    CHAR_LIT        shift and go to state 28
    FLOAT_LIT       shift and go to state 29
    INT_LIT         shift and go to state 30
    BOOL_LIT        shift and go to state 31
    IDENT           shift and go to state 23
    CONST           shift and go to state 22
    (               shift and go to state 32
    !               shift and go to state 34

    expr                           shift and go to state 40
    location                       shift and go to state 33

state 20

    (10) var_decl -> type_spec IDENT ; .
    CONST           reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    CHAR            reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    BOOL            reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    FLOAT           reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    INT             reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    VOID            reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    $end            reduce using rule 10 (var_decl -> type_spec IDENT ; .)


state 21

    (9) var_decl -> type_spec IDENT = . expr ;
    (47) expr -> . - expr
    (48) expr -> . + expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . CHAR_LIT
    (51) expr -> . FLOAT_LIT
    (52) expr -> . INT_LIT
    (53) expr -> . BOOL_LIT
    (54) expr -> . IDENT . SIZE
    (55) expr -> . IDENT ( args )
    (56) expr -> . CONST
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . ! expr
    (60) expr -> . expr % expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (65) expr -> . expr > expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr < expr
    (68) expr -> . expr LE expr
    (69) expr -> . expr NE expr
    (70) expr -> . expr EQ expr
    (71) expr -> . expr AND expr
    (72) expr -> . expr OR expr
    (73) expr -> . location = expr
    (45) location -> . IDENT [ expr ]
    (46) location -> . IDENT
    -               shift and go to state 25
    +               shift and go to state 26
    NEW             shift and go to state 27
    CHAR_LIT        shift and go to state 28
    FLOAT_LIT       shift and go to state 29
    INT_LIT         shift and go to state 30
    BOOL_LIT        shift and go to state 31
    IDENT           shift and go to state 23
    CONST           shift and go to state 22
    (               shift and go to state 32
    !               shift and go to state 34

    expr                           shift and go to state 41
    location                       shift and go to state 33

state 22

    (56) expr -> CONST .
    ;               reduce using rule 56 (expr -> CONST .)
    %               reduce using rule 56 (expr -> CONST .)
    /               reduce using rule 56 (expr -> CONST .)
    *               reduce using rule 56 (expr -> CONST .)
    -               reduce using rule 56 (expr -> CONST .)
    +               reduce using rule 56 (expr -> CONST .)
    >               reduce using rule 56 (expr -> CONST .)
    GE              reduce using rule 56 (expr -> CONST .)
    <               reduce using rule 56 (expr -> CONST .)
    LE              reduce using rule 56 (expr -> CONST .)
    NE              reduce using rule 56 (expr -> CONST .)
    EQ              reduce using rule 56 (expr -> CONST .)
    AND             reduce using rule 56 (expr -> CONST .)
    OR              reduce using rule 56 (expr -> CONST .)
    ]               reduce using rule 56 (expr -> CONST .)
    )               reduce using rule 56 (expr -> CONST .)
    ,               reduce using rule 56 (expr -> CONST .)


state 23

    (54) expr -> IDENT . . SIZE
    (55) expr -> IDENT . ( args )
    (45) location -> IDENT . [ expr ]
    (46) location -> IDENT .
    .               shift and go to state 42
    (               shift and go to state 43
    [               shift and go to state 44
    =               reduce using rule 46 (location -> IDENT .)
    ;               reduce using rule 46 (location -> IDENT .)
    %               reduce using rule 46 (location -> IDENT .)
    /               reduce using rule 46 (location -> IDENT .)
    *               reduce using rule 46 (location -> IDENT .)
    -               reduce using rule 46 (location -> IDENT .)
    +               reduce using rule 46 (location -> IDENT .)
    >               reduce using rule 46 (location -> IDENT .)
    GE              reduce using rule 46 (location -> IDENT .)
    <               reduce using rule 46 (location -> IDENT .)
    LE              reduce using rule 46 (location -> IDENT .)
    NE              reduce using rule 46 (location -> IDENT .)
    EQ              reduce using rule 46 (location -> IDENT .)
    AND             reduce using rule 46 (location -> IDENT .)
    OR              reduce using rule 46 (location -> IDENT .)
    ]               reduce using rule 46 (location -> IDENT .)
    )               reduce using rule 46 (location -> IDENT .)
    ,               reduce using rule 46 (location -> IDENT .)


state 24

    (7) const_decl -> CONST IDENT = expr . ;
    (60) expr -> expr . % expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    (65) expr -> expr . > expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . < expr
    (68) expr -> expr . LE expr
    (69) expr -> expr . NE expr
    (70) expr -> expr . EQ expr
    (71) expr -> expr . AND expr
    (72) expr -> expr . OR expr
    ;               shift and go to state 45
    %               shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    -               shift and go to state 49
    +               shift and go to state 50
    >               shift and go to state 51
    GE              shift and go to state 52
    <               shift and go to state 53
    LE              shift and go to state 54
    NE              shift and go to state 55
    EQ              shift and go to state 56
    AND             shift and go to state 57
    OR              shift and go to state 58


state 25

    (47) expr -> - . expr
    (47) expr -> . - expr
    (48) expr -> . + expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . CHAR_LIT
    (51) expr -> . FLOAT_LIT
    (52) expr -> . INT_LIT
    (53) expr -> . BOOL_LIT
    (54) expr -> . IDENT . SIZE
    (55) expr -> . IDENT ( args )
    (56) expr -> . CONST
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . ! expr
    (60) expr -> . expr % expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (65) expr -> . expr > expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr < expr
    (68) expr -> . expr LE expr
    (69) expr -> . expr NE expr
    (70) expr -> . expr EQ expr
    (71) expr -> . expr AND expr
    (72) expr -> . expr OR expr
    (73) expr -> . location = expr
    (45) location -> . IDENT [ expr ]
    (46) location -> . IDENT
    -               shift and go to state 25
    +               shift and go to state 26
    NEW             shift and go to state 27
    CHAR_LIT        shift and go to state 28
    FLOAT_LIT       shift and go to state 29
    INT_LIT         shift and go to state 30
    BOOL_LIT        shift and go to state 31
    IDENT           shift and go to state 23
    CONST           shift and go to state 22
    (               shift and go to state 32
    !               shift and go to state 34

    expr                           shift and go to state 59
    location                       shift and go to state 33

state 26

    (48) expr -> + . expr
    (47) expr -> . - expr
    (48) expr -> . + expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . CHAR_LIT
    (51) expr -> . FLOAT_LIT
    (52) expr -> . INT_LIT
    (53) expr -> . BOOL_LIT
    (54) expr -> . IDENT . SIZE
    (55) expr -> . IDENT ( args )
    (56) expr -> . CONST
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . ! expr
    (60) expr -> . expr % expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (65) expr -> . expr > expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr < expr
    (68) expr -> . expr LE expr
    (69) expr -> . expr NE expr
    (70) expr -> . expr EQ expr
    (71) expr -> . expr AND expr
    (72) expr -> . expr OR expr
    (73) expr -> . location = expr
    (45) location -> . IDENT [ expr ]
    (46) location -> . IDENT
    -               shift and go to state 25
    +               shift and go to state 26
    NEW             shift and go to state 27
    CHAR_LIT        shift and go to state 28
    FLOAT_LIT       shift and go to state 29
    INT_LIT         shift and go to state 30
    BOOL_LIT        shift and go to state 31
    IDENT           shift and go to state 23
    CONST           shift and go to state 22
    (               shift and go to state 32
    !               shift and go to state 34

    expr                           shift and go to state 60
    location                       shift and go to state 33

state 27

    (49) expr -> NEW . type_spec [ expr ]
    (11) type_spec -> . CHAR
    (12) type_spec -> . BOOL
    (13) type_spec -> . FLOAT
    (14) type_spec -> . INT
    (15) type_spec -> . VOID
    CHAR            shift and go to state 9
    BOOL            shift and go to state 10
    FLOAT           shift and go to state 11
    INT             shift and go to state 12
    VOID            shift and go to state 13

    type_spec                      shift and go to state 61

state 28

    (50) expr -> CHAR_LIT .
    ;               reduce using rule 50 (expr -> CHAR_LIT .)
    %               reduce using rule 50 (expr -> CHAR_LIT .)
    /               reduce using rule 50 (expr -> CHAR_LIT .)
    *               reduce using rule 50 (expr -> CHAR_LIT .)
    -               reduce using rule 50 (expr -> CHAR_LIT .)
    +               reduce using rule 50 (expr -> CHAR_LIT .)
    >               reduce using rule 50 (expr -> CHAR_LIT .)
    GE              reduce using rule 50 (expr -> CHAR_LIT .)
    <               reduce using rule 50 (expr -> CHAR_LIT .)
    LE              reduce using rule 50 (expr -> CHAR_LIT .)
    NE              reduce using rule 50 (expr -> CHAR_LIT .)
    EQ              reduce using rule 50 (expr -> CHAR_LIT .)
    AND             reduce using rule 50 (expr -> CHAR_LIT .)
    OR              reduce using rule 50 (expr -> CHAR_LIT .)
    ]               reduce using rule 50 (expr -> CHAR_LIT .)
    )               reduce using rule 50 (expr -> CHAR_LIT .)
    ,               reduce using rule 50 (expr -> CHAR_LIT .)


state 29

    (51) expr -> FLOAT_LIT .
    ;               reduce using rule 51 (expr -> FLOAT_LIT .)
    %               reduce using rule 51 (expr -> FLOAT_LIT .)
    /               reduce using rule 51 (expr -> FLOAT_LIT .)
    *               reduce using rule 51 (expr -> FLOAT_LIT .)
    -               reduce using rule 51 (expr -> FLOAT_LIT .)
    +               reduce using rule 51 (expr -> FLOAT_LIT .)
    >               reduce using rule 51 (expr -> FLOAT_LIT .)
    GE              reduce using rule 51 (expr -> FLOAT_LIT .)
    <               reduce using rule 51 (expr -> FLOAT_LIT .)
    LE              reduce using rule 51 (expr -> FLOAT_LIT .)
    NE              reduce using rule 51 (expr -> FLOAT_LIT .)
    EQ              reduce using rule 51 (expr -> FLOAT_LIT .)
    AND             reduce using rule 51 (expr -> FLOAT_LIT .)
    OR              reduce using rule 51 (expr -> FLOAT_LIT .)
    ]               reduce using rule 51 (expr -> FLOAT_LIT .)
    )               reduce using rule 51 (expr -> FLOAT_LIT .)
    ,               reduce using rule 51 (expr -> FLOAT_LIT .)


state 30

    (52) expr -> INT_LIT .
    ;               reduce using rule 52 (expr -> INT_LIT .)
    %               reduce using rule 52 (expr -> INT_LIT .)
    /               reduce using rule 52 (expr -> INT_LIT .)
    *               reduce using rule 52 (expr -> INT_LIT .)
    -               reduce using rule 52 (expr -> INT_LIT .)
    +               reduce using rule 52 (expr -> INT_LIT .)
    >               reduce using rule 52 (expr -> INT_LIT .)
    GE              reduce using rule 52 (expr -> INT_LIT .)
    <               reduce using rule 52 (expr -> INT_LIT .)
    LE              reduce using rule 52 (expr -> INT_LIT .)
    NE              reduce using rule 52 (expr -> INT_LIT .)
    EQ              reduce using rule 52 (expr -> INT_LIT .)
    AND             reduce using rule 52 (expr -> INT_LIT .)
    OR              reduce using rule 52 (expr -> INT_LIT .)
    ]               reduce using rule 52 (expr -> INT_LIT .)
    )               reduce using rule 52 (expr -> INT_LIT .)
    ,               reduce using rule 52 (expr -> INT_LIT .)


state 31

    (53) expr -> BOOL_LIT .
    ;               reduce using rule 53 (expr -> BOOL_LIT .)
    %               reduce using rule 53 (expr -> BOOL_LIT .)
    /               reduce using rule 53 (expr -> BOOL_LIT .)
    *               reduce using rule 53 (expr -> BOOL_LIT .)
    -               reduce using rule 53 (expr -> BOOL_LIT .)
    +               reduce using rule 53 (expr -> BOOL_LIT .)
    >               reduce using rule 53 (expr -> BOOL_LIT .)
    GE              reduce using rule 53 (expr -> BOOL_LIT .)
    <               reduce using rule 53 (expr -> BOOL_LIT .)
    LE              reduce using rule 53 (expr -> BOOL_LIT .)
    NE              reduce using rule 53 (expr -> BOOL_LIT .)
    EQ              reduce using rule 53 (expr -> BOOL_LIT .)
    AND             reduce using rule 53 (expr -> BOOL_LIT .)
    OR              reduce using rule 53 (expr -> BOOL_LIT .)
    ]               reduce using rule 53 (expr -> BOOL_LIT .)
    )               reduce using rule 53 (expr -> BOOL_LIT .)
    ,               reduce using rule 53 (expr -> BOOL_LIT .)


state 32

    (58) expr -> ( . expr )
    (47) expr -> . - expr
    (48) expr -> . + expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . CHAR_LIT
    (51) expr -> . FLOAT_LIT
    (52) expr -> . INT_LIT
    (53) expr -> . BOOL_LIT
    (54) expr -> . IDENT . SIZE
    (55) expr -> . IDENT ( args )
    (56) expr -> . CONST
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . ! expr
    (60) expr -> . expr % expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (65) expr -> . expr > expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr < expr
    (68) expr -> . expr LE expr
    (69) expr -> . expr NE expr
    (70) expr -> . expr EQ expr
    (71) expr -> . expr AND expr
    (72) expr -> . expr OR expr
    (73) expr -> . location = expr
    (45) location -> . IDENT [ expr ]
    (46) location -> . IDENT
    -               shift and go to state 25
    +               shift and go to state 26
    NEW             shift and go to state 27
    CHAR_LIT        shift and go to state 28
    FLOAT_LIT       shift and go to state 29
    INT_LIT         shift and go to state 30
    BOOL_LIT        shift and go to state 31
    IDENT           shift and go to state 23
    CONST           shift and go to state 22
    (               shift and go to state 32
    !               shift and go to state 34

    expr                           shift and go to state 62
    location                       shift and go to state 33

state 33

    (57) expr -> location .
    (73) expr -> location . = expr
    ;               reduce using rule 57 (expr -> location .)
    %               reduce using rule 57 (expr -> location .)
    /               reduce using rule 57 (expr -> location .)
    *               reduce using rule 57 (expr -> location .)
    -               reduce using rule 57 (expr -> location .)
    +               reduce using rule 57 (expr -> location .)
    >               reduce using rule 57 (expr -> location .)
    GE              reduce using rule 57 (expr -> location .)
    <               reduce using rule 57 (expr -> location .)
    LE              reduce using rule 57 (expr -> location .)
    NE              reduce using rule 57 (expr -> location .)
    EQ              reduce using rule 57 (expr -> location .)
    AND             reduce using rule 57 (expr -> location .)
    OR              reduce using rule 57 (expr -> location .)
    ]               reduce using rule 57 (expr -> location .)
    )               reduce using rule 57 (expr -> location .)
    ,               reduce using rule 57 (expr -> location .)
    =               shift and go to state 63


state 34

    (59) expr -> ! . expr
    (47) expr -> . - expr
    (48) expr -> . + expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . CHAR_LIT
    (51) expr -> . FLOAT_LIT
    (52) expr -> . INT_LIT
    (53) expr -> . BOOL_LIT
    (54) expr -> . IDENT . SIZE
    (55) expr -> . IDENT ( args )
    (56) expr -> . CONST
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . ! expr
    (60) expr -> . expr % expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (65) expr -> . expr > expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr < expr
    (68) expr -> . expr LE expr
    (69) expr -> . expr NE expr
    (70) expr -> . expr EQ expr
    (71) expr -> . expr AND expr
    (72) expr -> . expr OR expr
    (73) expr -> . location = expr
    (45) location -> . IDENT [ expr ]
    (46) location -> . IDENT
    -               shift and go to state 25
    +               shift and go to state 26
    NEW             shift and go to state 27
    CHAR_LIT        shift and go to state 28
    FLOAT_LIT       shift and go to state 29
    INT_LIT         shift and go to state 30
    BOOL_LIT        shift and go to state 31
    IDENT           shift and go to state 23
    CONST           shift and go to state 22
    (               shift and go to state 32
    !               shift and go to state 34

    expr                           shift and go to state 64
    location                       shift and go to state 33

state 35

    (21) param -> type_spec . IDENT [ ]
    (22) param -> type_spec . IDENT
    IDENT           shift and go to state 65


state 36

    (16) fun_decl -> type_spec IDENT ( params . ) compound_stmt
    )               shift and go to state 66


state 37

    (17) params -> VOID .
    (15) type_spec -> VOID .
    )               reduce using rule 17 (params -> VOID .)
    IDENT           reduce using rule 15 (type_spec -> VOID .)


state 38

    (18) params -> param_list .
    (20) param_list -> param_list . , param
    )               reduce using rule 18 (params -> param_list .)
    ,               shift and go to state 67


state 39

    (19) param_list -> param .
    ,               reduce using rule 19 (param_list -> param .)
    )               reduce using rule 19 (param_list -> param .)


state 40

    (8) var_decl -> type_spec IDENT [ expr . ] ;
    (60) expr -> expr . % expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    (65) expr -> expr . > expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . < expr
    (68) expr -> expr . LE expr
    (69) expr -> expr . NE expr
    (70) expr -> expr . EQ expr
    (71) expr -> expr . AND expr
    (72) expr -> expr . OR expr
    ]               shift and go to state 68
    %               shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    -               shift and go to state 49
    +               shift and go to state 50
    >               shift and go to state 51
    GE              shift and go to state 52
    <               shift and go to state 53
    LE              shift and go to state 54
    NE              shift and go to state 55
    EQ              shift and go to state 56
    AND             shift and go to state 57
    OR              shift and go to state 58


state 41

    (9) var_decl -> type_spec IDENT = expr . ;
    (60) expr -> expr . % expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    (65) expr -> expr . > expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . < expr
    (68) expr -> expr . LE expr
    (69) expr -> expr . NE expr
    (70) expr -> expr . EQ expr
    (71) expr -> expr . AND expr
    (72) expr -> expr . OR expr
    ;               shift and go to state 69
    %               shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    -               shift and go to state 49
    +               shift and go to state 50
    >               shift and go to state 51
    GE              shift and go to state 52
    <               shift and go to state 53
    LE              shift and go to state 54
    NE              shift and go to state 55
    EQ              shift and go to state 56
    AND             shift and go to state 57
    OR              shift and go to state 58


state 42

    (54) expr -> IDENT . . SIZE
    SIZE            shift and go to state 70


state 43

    (55) expr -> IDENT ( . args )
    (76) args -> . empty
    (77) args -> . arg_list
    (78) empty -> .
    (74) arg_list -> . expr
    (75) arg_list -> . arg_list , expr
    (47) expr -> . - expr
    (48) expr -> . + expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . CHAR_LIT
    (51) expr -> . FLOAT_LIT
    (52) expr -> . INT_LIT
    (53) expr -> . BOOL_LIT
    (54) expr -> . IDENT . SIZE
    (55) expr -> . IDENT ( args )
    (56) expr -> . CONST
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . ! expr
    (60) expr -> . expr % expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (65) expr -> . expr > expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr < expr
    (68) expr -> . expr LE expr
    (69) expr -> . expr NE expr
    (70) expr -> . expr EQ expr
    (71) expr -> . expr AND expr
    (72) expr -> . expr OR expr
    (73) expr -> . location = expr
    (45) location -> . IDENT [ expr ]
    (46) location -> . IDENT
    )               reduce using rule 78 (empty -> .)
    -               shift and go to state 25
    +               shift and go to state 26
    NEW             shift and go to state 27
    CHAR_LIT        shift and go to state 28
    FLOAT_LIT       shift and go to state 29
    INT_LIT         shift and go to state 30
    BOOL_LIT        shift and go to state 31
    IDENT           shift and go to state 23
    CONST           shift and go to state 22
    (               shift and go to state 32
    !               shift and go to state 34

    args                           shift and go to state 71
    empty                          shift and go to state 72
    arg_list                       shift and go to state 73
    expr                           shift and go to state 74
    location                       shift and go to state 33

state 44

    (45) location -> IDENT [ . expr ]
    (47) expr -> . - expr
    (48) expr -> . + expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . CHAR_LIT
    (51) expr -> . FLOAT_LIT
    (52) expr -> . INT_LIT
    (53) expr -> . BOOL_LIT
    (54) expr -> . IDENT . SIZE
    (55) expr -> . IDENT ( args )
    (56) expr -> . CONST
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . ! expr
    (60) expr -> . expr % expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (65) expr -> . expr > expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr < expr
    (68) expr -> . expr LE expr
    (69) expr -> . expr NE expr
    (70) expr -> . expr EQ expr
    (71) expr -> . expr AND expr
    (72) expr -> . expr OR expr
    (73) expr -> . location = expr
    (45) location -> . IDENT [ expr ]
    (46) location -> . IDENT
    -               shift and go to state 25
    +               shift and go to state 26
    NEW             shift and go to state 27
    CHAR_LIT        shift and go to state 28
    FLOAT_LIT       shift and go to state 29
    INT_LIT         shift and go to state 30
    BOOL_LIT        shift and go to state 31
    IDENT           shift and go to state 23
    CONST           shift and go to state 22
    (               shift and go to state 32
    !               shift and go to state 34

    expr                           shift and go to state 75
    location                       shift and go to state 33

state 45

    (7) const_decl -> CONST IDENT = expr ; .
    CONST           reduce using rule 7 (const_decl -> CONST IDENT = expr ; .)
    CHAR            reduce using rule 7 (const_decl -> CONST IDENT = expr ; .)
    BOOL            reduce using rule 7 (const_decl -> CONST IDENT = expr ; .)
    FLOAT           reduce using rule 7 (const_decl -> CONST IDENT = expr ; .)
    INT             reduce using rule 7 (const_decl -> CONST IDENT = expr ; .)
    VOID            reduce using rule 7 (const_decl -> CONST IDENT = expr ; .)
    $end            reduce using rule 7 (const_decl -> CONST IDENT = expr ; .)


state 46

    (60) expr -> expr % . expr
    (47) expr -> . - expr
    (48) expr -> . + expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . CHAR_LIT
    (51) expr -> . FLOAT_LIT
    (52) expr -> . INT_LIT
    (53) expr -> . BOOL_LIT
    (54) expr -> . IDENT . SIZE
    (55) expr -> . IDENT ( args )
    (56) expr -> . CONST
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . ! expr
    (60) expr -> . expr % expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (65) expr -> . expr > expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr < expr
    (68) expr -> . expr LE expr
    (69) expr -> . expr NE expr
    (70) expr -> . expr EQ expr
    (71) expr -> . expr AND expr
    (72) expr -> . expr OR expr
    (73) expr -> . location = expr
    (45) location -> . IDENT [ expr ]
    (46) location -> . IDENT
    -               shift and go to state 25
    +               shift and go to state 26
    NEW             shift and go to state 27
    CHAR_LIT        shift and go to state 28
    FLOAT_LIT       shift and go to state 29
    INT_LIT         shift and go to state 30
    BOOL_LIT        shift and go to state 31
    IDENT           shift and go to state 23
    CONST           shift and go to state 22
    (               shift and go to state 32
    !               shift and go to state 34

    expr                           shift and go to state 76
    location                       shift and go to state 33

state 47

    (61) expr -> expr / . expr
    (47) expr -> . - expr
    (48) expr -> . + expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . CHAR_LIT
    (51) expr -> . FLOAT_LIT
    (52) expr -> . INT_LIT
    (53) expr -> . BOOL_LIT
    (54) expr -> . IDENT . SIZE
    (55) expr -> . IDENT ( args )
    (56) expr -> . CONST
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . ! expr
    (60) expr -> . expr % expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (65) expr -> . expr > expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr < expr
    (68) expr -> . expr LE expr
    (69) expr -> . expr NE expr
    (70) expr -> . expr EQ expr
    (71) expr -> . expr AND expr
    (72) expr -> . expr OR expr
    (73) expr -> . location = expr
    (45) location -> . IDENT [ expr ]
    (46) location -> . IDENT
    -               shift and go to state 25
    +               shift and go to state 26
    NEW             shift and go to state 27
    CHAR_LIT        shift and go to state 28
    FLOAT_LIT       shift and go to state 29
    INT_LIT         shift and go to state 30
    BOOL_LIT        shift and go to state 31
    IDENT           shift and go to state 23
    CONST           shift and go to state 22
    (               shift and go to state 32
    !               shift and go to state 34

    expr                           shift and go to state 77
    location                       shift and go to state 33

state 48

    (62) expr -> expr * . expr
    (47) expr -> . - expr
    (48) expr -> . + expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . CHAR_LIT
    (51) expr -> . FLOAT_LIT
    (52) expr -> . INT_LIT
    (53) expr -> . BOOL_LIT
    (54) expr -> . IDENT . SIZE
    (55) expr -> . IDENT ( args )
    (56) expr -> . CONST
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . ! expr
    (60) expr -> . expr % expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (65) expr -> . expr > expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr < expr
    (68) expr -> . expr LE expr
    (69) expr -> . expr NE expr
    (70) expr -> . expr EQ expr
    (71) expr -> . expr AND expr
    (72) expr -> . expr OR expr
    (73) expr -> . location = expr
    (45) location -> . IDENT [ expr ]
    (46) location -> . IDENT
    -               shift and go to state 25
    +               shift and go to state 26
    NEW             shift and go to state 27
    CHAR_LIT        shift and go to state 28
    FLOAT_LIT       shift and go to state 29
    INT_LIT         shift and go to state 30
    BOOL_LIT        shift and go to state 31
    IDENT           shift and go to state 23
    CONST           shift and go to state 22
    (               shift and go to state 32
    !               shift and go to state 34

    expr                           shift and go to state 78
    location                       shift and go to state 33

state 49

    (63) expr -> expr - . expr
    (47) expr -> . - expr
    (48) expr -> . + expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . CHAR_LIT
    (51) expr -> . FLOAT_LIT
    (52) expr -> . INT_LIT
    (53) expr -> . BOOL_LIT
    (54) expr -> . IDENT . SIZE
    (55) expr -> . IDENT ( args )
    (56) expr -> . CONST
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . ! expr
    (60) expr -> . expr % expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (65) expr -> . expr > expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr < expr
    (68) expr -> . expr LE expr
    (69) expr -> . expr NE expr
    (70) expr -> . expr EQ expr
    (71) expr -> . expr AND expr
    (72) expr -> . expr OR expr
    (73) expr -> . location = expr
    (45) location -> . IDENT [ expr ]
    (46) location -> . IDENT
    -               shift and go to state 25
    +               shift and go to state 26
    NEW             shift and go to state 27
    CHAR_LIT        shift and go to state 28
    FLOAT_LIT       shift and go to state 29
    INT_LIT         shift and go to state 30
    BOOL_LIT        shift and go to state 31
    IDENT           shift and go to state 23
    CONST           shift and go to state 22
    (               shift and go to state 32
    !               shift and go to state 34

    expr                           shift and go to state 79
    location                       shift and go to state 33

state 50

    (64) expr -> expr + . expr
    (47) expr -> . - expr
    (48) expr -> . + expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . CHAR_LIT
    (51) expr -> . FLOAT_LIT
    (52) expr -> . INT_LIT
    (53) expr -> . BOOL_LIT
    (54) expr -> . IDENT . SIZE
    (55) expr -> . IDENT ( args )
    (56) expr -> . CONST
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . ! expr
    (60) expr -> . expr % expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (65) expr -> . expr > expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr < expr
    (68) expr -> . expr LE expr
    (69) expr -> . expr NE expr
    (70) expr -> . expr EQ expr
    (71) expr -> . expr AND expr
    (72) expr -> . expr OR expr
    (73) expr -> . location = expr
    (45) location -> . IDENT [ expr ]
    (46) location -> . IDENT
    -               shift and go to state 25
    +               shift and go to state 26
    NEW             shift and go to state 27
    CHAR_LIT        shift and go to state 28
    FLOAT_LIT       shift and go to state 29
    INT_LIT         shift and go to state 30
    BOOL_LIT        shift and go to state 31
    IDENT           shift and go to state 23
    CONST           shift and go to state 22
    (               shift and go to state 32
    !               shift and go to state 34

    expr                           shift and go to state 80
    location                       shift and go to state 33

state 51

    (65) expr -> expr > . expr
    (47) expr -> . - expr
    (48) expr -> . + expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . CHAR_LIT
    (51) expr -> . FLOAT_LIT
    (52) expr -> . INT_LIT
    (53) expr -> . BOOL_LIT
    (54) expr -> . IDENT . SIZE
    (55) expr -> . IDENT ( args )
    (56) expr -> . CONST
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . ! expr
    (60) expr -> . expr % expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (65) expr -> . expr > expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr < expr
    (68) expr -> . expr LE expr
    (69) expr -> . expr NE expr
    (70) expr -> . expr EQ expr
    (71) expr -> . expr AND expr
    (72) expr -> . expr OR expr
    (73) expr -> . location = expr
    (45) location -> . IDENT [ expr ]
    (46) location -> . IDENT
    -               shift and go to state 25
    +               shift and go to state 26
    NEW             shift and go to state 27
    CHAR_LIT        shift and go to state 28
    FLOAT_LIT       shift and go to state 29
    INT_LIT         shift and go to state 30
    BOOL_LIT        shift and go to state 31
    IDENT           shift and go to state 23
    CONST           shift and go to state 22
    (               shift and go to state 32
    !               shift and go to state 34

    expr                           shift and go to state 81
    location                       shift and go to state 33

state 52

    (66) expr -> expr GE . expr
    (47) expr -> . - expr
    (48) expr -> . + expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . CHAR_LIT
    (51) expr -> . FLOAT_LIT
    (52) expr -> . INT_LIT
    (53) expr -> . BOOL_LIT
    (54) expr -> . IDENT . SIZE
    (55) expr -> . IDENT ( args )
    (56) expr -> . CONST
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . ! expr
    (60) expr -> . expr % expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (65) expr -> . expr > expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr < expr
    (68) expr -> . expr LE expr
    (69) expr -> . expr NE expr
    (70) expr -> . expr EQ expr
    (71) expr -> . expr AND expr
    (72) expr -> . expr OR expr
    (73) expr -> . location = expr
    (45) location -> . IDENT [ expr ]
    (46) location -> . IDENT
    -               shift and go to state 25
    +               shift and go to state 26
    NEW             shift and go to state 27
    CHAR_LIT        shift and go to state 28
    FLOAT_LIT       shift and go to state 29
    INT_LIT         shift and go to state 30
    BOOL_LIT        shift and go to state 31
    IDENT           shift and go to state 23
    CONST           shift and go to state 22
    (               shift and go to state 32
    !               shift and go to state 34

    expr                           shift and go to state 82
    location                       shift and go to state 33

state 53

    (67) expr -> expr < . expr
    (47) expr -> . - expr
    (48) expr -> . + expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . CHAR_LIT
    (51) expr -> . FLOAT_LIT
    (52) expr -> . INT_LIT
    (53) expr -> . BOOL_LIT
    (54) expr -> . IDENT . SIZE
    (55) expr -> . IDENT ( args )
    (56) expr -> . CONST
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . ! expr
    (60) expr -> . expr % expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (65) expr -> . expr > expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr < expr
    (68) expr -> . expr LE expr
    (69) expr -> . expr NE expr
    (70) expr -> . expr EQ expr
    (71) expr -> . expr AND expr
    (72) expr -> . expr OR expr
    (73) expr -> . location = expr
    (45) location -> . IDENT [ expr ]
    (46) location -> . IDENT
    -               shift and go to state 25
    +               shift and go to state 26
    NEW             shift and go to state 27
    CHAR_LIT        shift and go to state 28
    FLOAT_LIT       shift and go to state 29
    INT_LIT         shift and go to state 30
    BOOL_LIT        shift and go to state 31
    IDENT           shift and go to state 23
    CONST           shift and go to state 22
    (               shift and go to state 32
    !               shift and go to state 34

    expr                           shift and go to state 83
    location                       shift and go to state 33

state 54

    (68) expr -> expr LE . expr
    (47) expr -> . - expr
    (48) expr -> . + expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . CHAR_LIT
    (51) expr -> . FLOAT_LIT
    (52) expr -> . INT_LIT
    (53) expr -> . BOOL_LIT
    (54) expr -> . IDENT . SIZE
    (55) expr -> . IDENT ( args )
    (56) expr -> . CONST
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . ! expr
    (60) expr -> . expr % expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (65) expr -> . expr > expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr < expr
    (68) expr -> . expr LE expr
    (69) expr -> . expr NE expr
    (70) expr -> . expr EQ expr
    (71) expr -> . expr AND expr
    (72) expr -> . expr OR expr
    (73) expr -> . location = expr
    (45) location -> . IDENT [ expr ]
    (46) location -> . IDENT
    -               shift and go to state 25
    +               shift and go to state 26
    NEW             shift and go to state 27
    CHAR_LIT        shift and go to state 28
    FLOAT_LIT       shift and go to state 29
    INT_LIT         shift and go to state 30
    BOOL_LIT        shift and go to state 31
    IDENT           shift and go to state 23
    CONST           shift and go to state 22
    (               shift and go to state 32
    !               shift and go to state 34

    expr                           shift and go to state 84
    location                       shift and go to state 33

state 55

    (69) expr -> expr NE . expr
    (47) expr -> . - expr
    (48) expr -> . + expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . CHAR_LIT
    (51) expr -> . FLOAT_LIT
    (52) expr -> . INT_LIT
    (53) expr -> . BOOL_LIT
    (54) expr -> . IDENT . SIZE
    (55) expr -> . IDENT ( args )
    (56) expr -> . CONST
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . ! expr
    (60) expr -> . expr % expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (65) expr -> . expr > expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr < expr
    (68) expr -> . expr LE expr
    (69) expr -> . expr NE expr
    (70) expr -> . expr EQ expr
    (71) expr -> . expr AND expr
    (72) expr -> . expr OR expr
    (73) expr -> . location = expr
    (45) location -> . IDENT [ expr ]
    (46) location -> . IDENT
    -               shift and go to state 25
    +               shift and go to state 26
    NEW             shift and go to state 27
    CHAR_LIT        shift and go to state 28
    FLOAT_LIT       shift and go to state 29
    INT_LIT         shift and go to state 30
    BOOL_LIT        shift and go to state 31
    IDENT           shift and go to state 23
    CONST           shift and go to state 22
    (               shift and go to state 32
    !               shift and go to state 34

    expr                           shift and go to state 85
    location                       shift and go to state 33

state 56

    (70) expr -> expr EQ . expr
    (47) expr -> . - expr
    (48) expr -> . + expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . CHAR_LIT
    (51) expr -> . FLOAT_LIT
    (52) expr -> . INT_LIT
    (53) expr -> . BOOL_LIT
    (54) expr -> . IDENT . SIZE
    (55) expr -> . IDENT ( args )
    (56) expr -> . CONST
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . ! expr
    (60) expr -> . expr % expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (65) expr -> . expr > expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr < expr
    (68) expr -> . expr LE expr
    (69) expr -> . expr NE expr
    (70) expr -> . expr EQ expr
    (71) expr -> . expr AND expr
    (72) expr -> . expr OR expr
    (73) expr -> . location = expr
    (45) location -> . IDENT [ expr ]
    (46) location -> . IDENT
    -               shift and go to state 25
    +               shift and go to state 26
    NEW             shift and go to state 27
    CHAR_LIT        shift and go to state 28
    FLOAT_LIT       shift and go to state 29
    INT_LIT         shift and go to state 30
    BOOL_LIT        shift and go to state 31
    IDENT           shift and go to state 23
    CONST           shift and go to state 22
    (               shift and go to state 32
    !               shift and go to state 34

    expr                           shift and go to state 86
    location                       shift and go to state 33

state 57

    (71) expr -> expr AND . expr
    (47) expr -> . - expr
    (48) expr -> . + expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . CHAR_LIT
    (51) expr -> . FLOAT_LIT
    (52) expr -> . INT_LIT
    (53) expr -> . BOOL_LIT
    (54) expr -> . IDENT . SIZE
    (55) expr -> . IDENT ( args )
    (56) expr -> . CONST
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . ! expr
    (60) expr -> . expr % expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (65) expr -> . expr > expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr < expr
    (68) expr -> . expr LE expr
    (69) expr -> . expr NE expr
    (70) expr -> . expr EQ expr
    (71) expr -> . expr AND expr
    (72) expr -> . expr OR expr
    (73) expr -> . location = expr
    (45) location -> . IDENT [ expr ]
    (46) location -> . IDENT
    -               shift and go to state 25
    +               shift and go to state 26
    NEW             shift and go to state 27
    CHAR_LIT        shift and go to state 28
    FLOAT_LIT       shift and go to state 29
    INT_LIT         shift and go to state 30
    BOOL_LIT        shift and go to state 31
    IDENT           shift and go to state 23
    CONST           shift and go to state 22
    (               shift and go to state 32
    !               shift and go to state 34

    expr                           shift and go to state 87
    location                       shift and go to state 33

state 58

    (72) expr -> expr OR . expr
    (47) expr -> . - expr
    (48) expr -> . + expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . CHAR_LIT
    (51) expr -> . FLOAT_LIT
    (52) expr -> . INT_LIT
    (53) expr -> . BOOL_LIT
    (54) expr -> . IDENT . SIZE
    (55) expr -> . IDENT ( args )
    (56) expr -> . CONST
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . ! expr
    (60) expr -> . expr % expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (65) expr -> . expr > expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr < expr
    (68) expr -> . expr LE expr
    (69) expr -> . expr NE expr
    (70) expr -> . expr EQ expr
    (71) expr -> . expr AND expr
    (72) expr -> . expr OR expr
    (73) expr -> . location = expr
    (45) location -> . IDENT [ expr ]
    (46) location -> . IDENT
    -               shift and go to state 25
    +               shift and go to state 26
    NEW             shift and go to state 27
    CHAR_LIT        shift and go to state 28
    FLOAT_LIT       shift and go to state 29
    INT_LIT         shift and go to state 30
    BOOL_LIT        shift and go to state 31
    IDENT           shift and go to state 23
    CONST           shift and go to state 22
    (               shift and go to state 32
    !               shift and go to state 34

    expr                           shift and go to state 88
    location                       shift and go to state 33

state 59

    (47) expr -> - expr .
    (60) expr -> expr . % expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    (65) expr -> expr . > expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . < expr
    (68) expr -> expr . LE expr
    (69) expr -> expr . NE expr
    (70) expr -> expr . EQ expr
    (71) expr -> expr . AND expr
    (72) expr -> expr . OR expr
    ;               reduce using rule 47 (expr -> - expr .)
    %               reduce using rule 47 (expr -> - expr .)
    /               reduce using rule 47 (expr -> - expr .)
    *               reduce using rule 47 (expr -> - expr .)
    -               reduce using rule 47 (expr -> - expr .)
    +               reduce using rule 47 (expr -> - expr .)
    >               reduce using rule 47 (expr -> - expr .)
    GE              reduce using rule 47 (expr -> - expr .)
    <               reduce using rule 47 (expr -> - expr .)
    LE              reduce using rule 47 (expr -> - expr .)
    NE              reduce using rule 47 (expr -> - expr .)
    EQ              reduce using rule 47 (expr -> - expr .)
    AND             reduce using rule 47 (expr -> - expr .)
    OR              reduce using rule 47 (expr -> - expr .)
    ]               reduce using rule 47 (expr -> - expr .)
    )               reduce using rule 47 (expr -> - expr .)
    ,               reduce using rule 47 (expr -> - expr .)


state 60

    (48) expr -> + expr .
    (60) expr -> expr . % expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    (65) expr -> expr . > expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . < expr
    (68) expr -> expr . LE expr
    (69) expr -> expr . NE expr
    (70) expr -> expr . EQ expr
    (71) expr -> expr . AND expr
    (72) expr -> expr . OR expr
    ;               reduce using rule 48 (expr -> + expr .)
    %               reduce using rule 48 (expr -> + expr .)
    /               reduce using rule 48 (expr -> + expr .)
    *               reduce using rule 48 (expr -> + expr .)
    -               reduce using rule 48 (expr -> + expr .)
    +               reduce using rule 48 (expr -> + expr .)
    >               reduce using rule 48 (expr -> + expr .)
    GE              reduce using rule 48 (expr -> + expr .)
    <               reduce using rule 48 (expr -> + expr .)
    LE              reduce using rule 48 (expr -> + expr .)
    NE              reduce using rule 48 (expr -> + expr .)
    EQ              reduce using rule 48 (expr -> + expr .)
    AND             reduce using rule 48 (expr -> + expr .)
    OR              reduce using rule 48 (expr -> + expr .)
    ]               reduce using rule 48 (expr -> + expr .)
    )               reduce using rule 48 (expr -> + expr .)
    ,               reduce using rule 48 (expr -> + expr .)


state 61

    (49) expr -> NEW type_spec . [ expr ]
    [               shift and go to state 89


state 62

    (58) expr -> ( expr . )
    (60) expr -> expr . % expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    (65) expr -> expr . > expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . < expr
    (68) expr -> expr . LE expr
    (69) expr -> expr . NE expr
    (70) expr -> expr . EQ expr
    (71) expr -> expr . AND expr
    (72) expr -> expr . OR expr
    )               shift and go to state 90
    %               shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    -               shift and go to state 49
    +               shift and go to state 50
    >               shift and go to state 51
    GE              shift and go to state 52
    <               shift and go to state 53
    LE              shift and go to state 54
    NE              shift and go to state 55
    EQ              shift and go to state 56
    AND             shift and go to state 57
    OR              shift and go to state 58


state 63

    (73) expr -> location = . expr
    (47) expr -> . - expr
    (48) expr -> . + expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . CHAR_LIT
    (51) expr -> . FLOAT_LIT
    (52) expr -> . INT_LIT
    (53) expr -> . BOOL_LIT
    (54) expr -> . IDENT . SIZE
    (55) expr -> . IDENT ( args )
    (56) expr -> . CONST
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . ! expr
    (60) expr -> . expr % expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (65) expr -> . expr > expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr < expr
    (68) expr -> . expr LE expr
    (69) expr -> . expr NE expr
    (70) expr -> . expr EQ expr
    (71) expr -> . expr AND expr
    (72) expr -> . expr OR expr
    (73) expr -> . location = expr
    (45) location -> . IDENT [ expr ]
    (46) location -> . IDENT
    -               shift and go to state 25
    +               shift and go to state 26
    NEW             shift and go to state 27
    CHAR_LIT        shift and go to state 28
    FLOAT_LIT       shift and go to state 29
    INT_LIT         shift and go to state 30
    BOOL_LIT        shift and go to state 31
    IDENT           shift and go to state 23
    CONST           shift and go to state 22
    (               shift and go to state 32
    !               shift and go to state 34

    location                       shift and go to state 33
    expr                           shift and go to state 91

state 64

    (59) expr -> ! expr .
    (60) expr -> expr . % expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    (65) expr -> expr . > expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . < expr
    (68) expr -> expr . LE expr
    (69) expr -> expr . NE expr
    (70) expr -> expr . EQ expr
    (71) expr -> expr . AND expr
    (72) expr -> expr . OR expr
    ;               reduce using rule 59 (expr -> ! expr .)
    %               reduce using rule 59 (expr -> ! expr .)
    /               reduce using rule 59 (expr -> ! expr .)
    *               reduce using rule 59 (expr -> ! expr .)
    -               reduce using rule 59 (expr -> ! expr .)
    +               reduce using rule 59 (expr -> ! expr .)
    >               reduce using rule 59 (expr -> ! expr .)
    GE              reduce using rule 59 (expr -> ! expr .)
    <               reduce using rule 59 (expr -> ! expr .)
    LE              reduce using rule 59 (expr -> ! expr .)
    NE              reduce using rule 59 (expr -> ! expr .)
    EQ              reduce using rule 59 (expr -> ! expr .)
    AND             reduce using rule 59 (expr -> ! expr .)
    OR              reduce using rule 59 (expr -> ! expr .)
    ]               reduce using rule 59 (expr -> ! expr .)
    )               reduce using rule 59 (expr -> ! expr .)
    ,               reduce using rule 59 (expr -> ! expr .)


state 65

    (21) param -> type_spec IDENT . [ ]
    (22) param -> type_spec IDENT .
    [               shift and go to state 92
    ,               reduce using rule 22 (param -> type_spec IDENT .)
    )               reduce using rule 22 (param -> type_spec IDENT .)


state 66

    (16) fun_decl -> type_spec IDENT ( params ) . compound_stmt
    (23) compound_stmt -> . { local_decls stmt_list }
    {               shift and go to state 94

    compound_stmt                  shift and go to state 93

state 67

    (20) param_list -> param_list , . param
    (21) param -> . type_spec IDENT [ ]
    (22) param -> . type_spec IDENT
    (11) type_spec -> . CHAR
    (12) type_spec -> . BOOL
    (13) type_spec -> . FLOAT
    (14) type_spec -> . INT
    (15) type_spec -> . VOID
    CHAR            shift and go to state 9
    BOOL            shift and go to state 10
    FLOAT           shift and go to state 11
    INT             shift and go to state 12
    VOID            shift and go to state 13

    param                          shift and go to state 95
    type_spec                      shift and go to state 35

state 68

    (8) var_decl -> type_spec IDENT [ expr ] . ;
    ;               shift and go to state 96


state 69

    (9) var_decl -> type_spec IDENT = expr ; .
    CONST           reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    CHAR            reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    BOOL            reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    FLOAT           reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    INT             reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    VOID            reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    $end            reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)


state 70

    (54) expr -> IDENT . SIZE .
    ;               reduce using rule 54 (expr -> IDENT . SIZE .)
    %               reduce using rule 54 (expr -> IDENT . SIZE .)
    /               reduce using rule 54 (expr -> IDENT . SIZE .)
    *               reduce using rule 54 (expr -> IDENT . SIZE .)
    -               reduce using rule 54 (expr -> IDENT . SIZE .)
    +               reduce using rule 54 (expr -> IDENT . SIZE .)
    >               reduce using rule 54 (expr -> IDENT . SIZE .)
    GE              reduce using rule 54 (expr -> IDENT . SIZE .)
    <               reduce using rule 54 (expr -> IDENT . SIZE .)
    LE              reduce using rule 54 (expr -> IDENT . SIZE .)
    NE              reduce using rule 54 (expr -> IDENT . SIZE .)
    EQ              reduce using rule 54 (expr -> IDENT . SIZE .)
    AND             reduce using rule 54 (expr -> IDENT . SIZE .)
    OR              reduce using rule 54 (expr -> IDENT . SIZE .)
    ]               reduce using rule 54 (expr -> IDENT . SIZE .)
    )               reduce using rule 54 (expr -> IDENT . SIZE .)
    ,               reduce using rule 54 (expr -> IDENT . SIZE .)


state 71

    (55) expr -> IDENT ( args . )
    )               shift and go to state 97


state 72

    (76) args -> empty .
    )               reduce using rule 76 (args -> empty .)


state 73

    (77) args -> arg_list .
    (75) arg_list -> arg_list . , expr
    )               reduce using rule 77 (args -> arg_list .)
    ,               shift and go to state 98


state 74

    (74) arg_list -> expr .
    (60) expr -> expr . % expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    (65) expr -> expr . > expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . < expr
    (68) expr -> expr . LE expr
    (69) expr -> expr . NE expr
    (70) expr -> expr . EQ expr
    (71) expr -> expr . AND expr
    (72) expr -> expr . OR expr
    ,               reduce using rule 74 (arg_list -> expr .)
    )               reduce using rule 74 (arg_list -> expr .)
    %               shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    -               shift and go to state 49
    +               shift and go to state 50
    >               shift and go to state 51
    GE              shift and go to state 52
    <               shift and go to state 53
    LE              shift and go to state 54
    NE              shift and go to state 55
    EQ              shift and go to state 56
    AND             shift and go to state 57
    OR              shift and go to state 58


state 75

    (45) location -> IDENT [ expr . ]
    (60) expr -> expr . % expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    (65) expr -> expr . > expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . < expr
    (68) expr -> expr . LE expr
    (69) expr -> expr . NE expr
    (70) expr -> expr . EQ expr
    (71) expr -> expr . AND expr
    (72) expr -> expr . OR expr
    ]               shift and go to state 99
    %               shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    -               shift and go to state 49
    +               shift and go to state 50
    >               shift and go to state 51
    GE              shift and go to state 52
    <               shift and go to state 53
    LE              shift and go to state 54
    NE              shift and go to state 55
    EQ              shift and go to state 56
    AND             shift and go to state 57
    OR              shift and go to state 58


state 76

    (60) expr -> expr % expr .
    (60) expr -> expr . % expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    (65) expr -> expr . > expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . < expr
    (68) expr -> expr . LE expr
    (69) expr -> expr . NE expr
    (70) expr -> expr . EQ expr
    (71) expr -> expr . AND expr
    (72) expr -> expr . OR expr
    ;               reduce using rule 60 (expr -> expr % expr .)
    %               reduce using rule 60 (expr -> expr % expr .)
    /               reduce using rule 60 (expr -> expr % expr .)
    *               reduce using rule 60 (expr -> expr % expr .)
    -               reduce using rule 60 (expr -> expr % expr .)
    +               reduce using rule 60 (expr -> expr % expr .)
    >               reduce using rule 60 (expr -> expr % expr .)
    GE              reduce using rule 60 (expr -> expr % expr .)
    <               reduce using rule 60 (expr -> expr % expr .)
    LE              reduce using rule 60 (expr -> expr % expr .)
    NE              reduce using rule 60 (expr -> expr % expr .)
    EQ              reduce using rule 60 (expr -> expr % expr .)
    AND             reduce using rule 60 (expr -> expr % expr .)
    OR              reduce using rule 60 (expr -> expr % expr .)
    ]               reduce using rule 60 (expr -> expr % expr .)
    )               reduce using rule 60 (expr -> expr % expr .)
    ,               reduce using rule 60 (expr -> expr % expr .)


state 77

    (61) expr -> expr / expr .
    (60) expr -> expr . % expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    (65) expr -> expr . > expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . < expr
    (68) expr -> expr . LE expr
    (69) expr -> expr . NE expr
    (70) expr -> expr . EQ expr
    (71) expr -> expr . AND expr
    (72) expr -> expr . OR expr
    ;               reduce using rule 61 (expr -> expr / expr .)
    %               reduce using rule 61 (expr -> expr / expr .)
    /               reduce using rule 61 (expr -> expr / expr .)
    *               reduce using rule 61 (expr -> expr / expr .)
    -               reduce using rule 61 (expr -> expr / expr .)
    +               reduce using rule 61 (expr -> expr / expr .)
    >               reduce using rule 61 (expr -> expr / expr .)
    GE              reduce using rule 61 (expr -> expr / expr .)
    <               reduce using rule 61 (expr -> expr / expr .)
    LE              reduce using rule 61 (expr -> expr / expr .)
    NE              reduce using rule 61 (expr -> expr / expr .)
    EQ              reduce using rule 61 (expr -> expr / expr .)
    AND             reduce using rule 61 (expr -> expr / expr .)
    OR              reduce using rule 61 (expr -> expr / expr .)
    ]               reduce using rule 61 (expr -> expr / expr .)
    )               reduce using rule 61 (expr -> expr / expr .)
    ,               reduce using rule 61 (expr -> expr / expr .)


state 78

    (62) expr -> expr * expr .
    (60) expr -> expr . % expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    (65) expr -> expr . > expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . < expr
    (68) expr -> expr . LE expr
    (69) expr -> expr . NE expr
    (70) expr -> expr . EQ expr
    (71) expr -> expr . AND expr
    (72) expr -> expr . OR expr
    ;               reduce using rule 62 (expr -> expr * expr .)
    %               reduce using rule 62 (expr -> expr * expr .)
    /               reduce using rule 62 (expr -> expr * expr .)
    *               reduce using rule 62 (expr -> expr * expr .)
    -               reduce using rule 62 (expr -> expr * expr .)
    +               reduce using rule 62 (expr -> expr * expr .)
    >               reduce using rule 62 (expr -> expr * expr .)
    GE              reduce using rule 62 (expr -> expr * expr .)
    <               reduce using rule 62 (expr -> expr * expr .)
    LE              reduce using rule 62 (expr -> expr * expr .)
    NE              reduce using rule 62 (expr -> expr * expr .)
    EQ              reduce using rule 62 (expr -> expr * expr .)
    AND             reduce using rule 62 (expr -> expr * expr .)
    OR              reduce using rule 62 (expr -> expr * expr .)
    ]               reduce using rule 62 (expr -> expr * expr .)
    )               reduce using rule 62 (expr -> expr * expr .)
    ,               reduce using rule 62 (expr -> expr * expr .)


state 79

    (63) expr -> expr - expr .
    (60) expr -> expr . % expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    (65) expr -> expr . > expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . < expr
    (68) expr -> expr . LE expr
    (69) expr -> expr . NE expr
    (70) expr -> expr . EQ expr
    (71) expr -> expr . AND expr
    (72) expr -> expr . OR expr
    ;               reduce using rule 63 (expr -> expr - expr .)
    -               reduce using rule 63 (expr -> expr - expr .)
    +               reduce using rule 63 (expr -> expr - expr .)
    >               reduce using rule 63 (expr -> expr - expr .)
    GE              reduce using rule 63 (expr -> expr - expr .)
    <               reduce using rule 63 (expr -> expr - expr .)
    LE              reduce using rule 63 (expr -> expr - expr .)
    NE              reduce using rule 63 (expr -> expr - expr .)
    EQ              reduce using rule 63 (expr -> expr - expr .)
    AND             reduce using rule 63 (expr -> expr - expr .)
    OR              reduce using rule 63 (expr -> expr - expr .)
    ]               reduce using rule 63 (expr -> expr - expr .)
    )               reduce using rule 63 (expr -> expr - expr .)
    ,               reduce using rule 63 (expr -> expr - expr .)
    %               shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48


state 80

    (64) expr -> expr + expr .
    (60) expr -> expr . % expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    (65) expr -> expr . > expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . < expr
    (68) expr -> expr . LE expr
    (69) expr -> expr . NE expr
    (70) expr -> expr . EQ expr
    (71) expr -> expr . AND expr
    (72) expr -> expr . OR expr
    ;               reduce using rule 64 (expr -> expr + expr .)
    -               reduce using rule 64 (expr -> expr + expr .)
    +               reduce using rule 64 (expr -> expr + expr .)
    >               reduce using rule 64 (expr -> expr + expr .)
    GE              reduce using rule 64 (expr -> expr + expr .)
    <               reduce using rule 64 (expr -> expr + expr .)
    LE              reduce using rule 64 (expr -> expr + expr .)
    NE              reduce using rule 64 (expr -> expr + expr .)
    EQ              reduce using rule 64 (expr -> expr + expr .)
    AND             reduce using rule 64 (expr -> expr + expr .)
    OR              reduce using rule 64 (expr -> expr + expr .)
    ]               reduce using rule 64 (expr -> expr + expr .)
    )               reduce using rule 64 (expr -> expr + expr .)
    ,               reduce using rule 64 (expr -> expr + expr .)
    %               shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48


state 81

    (65) expr -> expr > expr .
    (60) expr -> expr . % expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    (65) expr -> expr . > expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . < expr
    (68) expr -> expr . LE expr
    (69) expr -> expr . NE expr
    (70) expr -> expr . EQ expr
    (71) expr -> expr . AND expr
    (72) expr -> expr . OR expr
    ;               reduce using rule 65 (expr -> expr > expr .)
    >               reduce using rule 65 (expr -> expr > expr .)
    GE              reduce using rule 65 (expr -> expr > expr .)
    <               reduce using rule 65 (expr -> expr > expr .)
    LE              reduce using rule 65 (expr -> expr > expr .)
    NE              reduce using rule 65 (expr -> expr > expr .)
    EQ              reduce using rule 65 (expr -> expr > expr .)
    AND             reduce using rule 65 (expr -> expr > expr .)
    OR              reduce using rule 65 (expr -> expr > expr .)
    ]               reduce using rule 65 (expr -> expr > expr .)
    )               reduce using rule 65 (expr -> expr > expr .)
    ,               reduce using rule 65 (expr -> expr > expr .)
    %               shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    -               shift and go to state 49
    +               shift and go to state 50


state 82

    (66) expr -> expr GE expr .
    (60) expr -> expr . % expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    (65) expr -> expr . > expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . < expr
    (68) expr -> expr . LE expr
    (69) expr -> expr . NE expr
    (70) expr -> expr . EQ expr
    (71) expr -> expr . AND expr
    (72) expr -> expr . OR expr
    ;               reduce using rule 66 (expr -> expr GE expr .)
    >               reduce using rule 66 (expr -> expr GE expr .)
    GE              reduce using rule 66 (expr -> expr GE expr .)
    <               reduce using rule 66 (expr -> expr GE expr .)
    LE              reduce using rule 66 (expr -> expr GE expr .)
    NE              reduce using rule 66 (expr -> expr GE expr .)
    EQ              reduce using rule 66 (expr -> expr GE expr .)
    AND             reduce using rule 66 (expr -> expr GE expr .)
    OR              reduce using rule 66 (expr -> expr GE expr .)
    ]               reduce using rule 66 (expr -> expr GE expr .)
    )               reduce using rule 66 (expr -> expr GE expr .)
    ,               reduce using rule 66 (expr -> expr GE expr .)
    %               shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    -               shift and go to state 49
    +               shift and go to state 50


state 83

    (67) expr -> expr < expr .
    (60) expr -> expr . % expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    (65) expr -> expr . > expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . < expr
    (68) expr -> expr . LE expr
    (69) expr -> expr . NE expr
    (70) expr -> expr . EQ expr
    (71) expr -> expr . AND expr
    (72) expr -> expr . OR expr
    ;               reduce using rule 67 (expr -> expr < expr .)
    >               reduce using rule 67 (expr -> expr < expr .)
    GE              reduce using rule 67 (expr -> expr < expr .)
    <               reduce using rule 67 (expr -> expr < expr .)
    LE              reduce using rule 67 (expr -> expr < expr .)
    NE              reduce using rule 67 (expr -> expr < expr .)
    EQ              reduce using rule 67 (expr -> expr < expr .)
    AND             reduce using rule 67 (expr -> expr < expr .)
    OR              reduce using rule 67 (expr -> expr < expr .)
    ]               reduce using rule 67 (expr -> expr < expr .)
    )               reduce using rule 67 (expr -> expr < expr .)
    ,               reduce using rule 67 (expr -> expr < expr .)
    %               shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    -               shift and go to state 49
    +               shift and go to state 50


state 84

    (68) expr -> expr LE expr .
    (60) expr -> expr . % expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    (65) expr -> expr . > expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . < expr
    (68) expr -> expr . LE expr
    (69) expr -> expr . NE expr
    (70) expr -> expr . EQ expr
    (71) expr -> expr . AND expr
    (72) expr -> expr . OR expr
    ;               reduce using rule 68 (expr -> expr LE expr .)
    >               reduce using rule 68 (expr -> expr LE expr .)
    GE              reduce using rule 68 (expr -> expr LE expr .)
    <               reduce using rule 68 (expr -> expr LE expr .)
    LE              reduce using rule 68 (expr -> expr LE expr .)
    NE              reduce using rule 68 (expr -> expr LE expr .)
    EQ              reduce using rule 68 (expr -> expr LE expr .)
    AND             reduce using rule 68 (expr -> expr LE expr .)
    OR              reduce using rule 68 (expr -> expr LE expr .)
    ]               reduce using rule 68 (expr -> expr LE expr .)
    )               reduce using rule 68 (expr -> expr LE expr .)
    ,               reduce using rule 68 (expr -> expr LE expr .)
    %               shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    -               shift and go to state 49
    +               shift and go to state 50


state 85

    (69) expr -> expr NE expr .
    (60) expr -> expr . % expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    (65) expr -> expr . > expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . < expr
    (68) expr -> expr . LE expr
    (69) expr -> expr . NE expr
    (70) expr -> expr . EQ expr
    (71) expr -> expr . AND expr
    (72) expr -> expr . OR expr
    ;               reduce using rule 69 (expr -> expr NE expr .)
    NE              reduce using rule 69 (expr -> expr NE expr .)
    EQ              reduce using rule 69 (expr -> expr NE expr .)
    AND             reduce using rule 69 (expr -> expr NE expr .)
    OR              reduce using rule 69 (expr -> expr NE expr .)
    ]               reduce using rule 69 (expr -> expr NE expr .)
    )               reduce using rule 69 (expr -> expr NE expr .)
    ,               reduce using rule 69 (expr -> expr NE expr .)
    %               shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    -               shift and go to state 49
    +               shift and go to state 50
    >               shift and go to state 51
    GE              shift and go to state 52
    <               shift and go to state 53
    LE              shift and go to state 54


state 86

    (70) expr -> expr EQ expr .
    (60) expr -> expr . % expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    (65) expr -> expr . > expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . < expr
    (68) expr -> expr . LE expr
    (69) expr -> expr . NE expr
    (70) expr -> expr . EQ expr
    (71) expr -> expr . AND expr
    (72) expr -> expr . OR expr
    ;               reduce using rule 70 (expr -> expr EQ expr .)
    NE              reduce using rule 70 (expr -> expr EQ expr .)
    EQ              reduce using rule 70 (expr -> expr EQ expr .)
    AND             reduce using rule 70 (expr -> expr EQ expr .)
    OR              reduce using rule 70 (expr -> expr EQ expr .)
    ]               reduce using rule 70 (expr -> expr EQ expr .)
    )               reduce using rule 70 (expr -> expr EQ expr .)
    ,               reduce using rule 70 (expr -> expr EQ expr .)
    %               shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    -               shift and go to state 49
    +               shift and go to state 50
    >               shift and go to state 51
    GE              shift and go to state 52
    <               shift and go to state 53
    LE              shift and go to state 54


state 87

    (71) expr -> expr AND expr .
    (60) expr -> expr . % expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    (65) expr -> expr . > expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . < expr
    (68) expr -> expr . LE expr
    (69) expr -> expr . NE expr
    (70) expr -> expr . EQ expr
    (71) expr -> expr . AND expr
    (72) expr -> expr . OR expr
    ;               reduce using rule 71 (expr -> expr AND expr .)
    AND             reduce using rule 71 (expr -> expr AND expr .)
    OR              reduce using rule 71 (expr -> expr AND expr .)
    ]               reduce using rule 71 (expr -> expr AND expr .)
    )               reduce using rule 71 (expr -> expr AND expr .)
    ,               reduce using rule 71 (expr -> expr AND expr .)
    %               shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    -               shift and go to state 49
    +               shift and go to state 50
    >               shift and go to state 51
    GE              shift and go to state 52
    <               shift and go to state 53
    LE              shift and go to state 54
    NE              shift and go to state 55
    EQ              shift and go to state 56


state 88

    (72) expr -> expr OR expr .
    (60) expr -> expr . % expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    (65) expr -> expr . > expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . < expr
    (68) expr -> expr . LE expr
    (69) expr -> expr . NE expr
    (70) expr -> expr . EQ expr
    (71) expr -> expr . AND expr
    (72) expr -> expr . OR expr
    ;               reduce using rule 72 (expr -> expr OR expr .)
    OR              reduce using rule 72 (expr -> expr OR expr .)
    ]               reduce using rule 72 (expr -> expr OR expr .)
    )               reduce using rule 72 (expr -> expr OR expr .)
    ,               reduce using rule 72 (expr -> expr OR expr .)
    %               shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    -               shift and go to state 49
    +               shift and go to state 50
    >               shift and go to state 51
    GE              shift and go to state 52
    <               shift and go to state 53
    LE              shift and go to state 54
    NE              shift and go to state 55
    EQ              shift and go to state 56
    AND             shift and go to state 57


state 89

    (49) expr -> NEW type_spec [ . expr ]
    (47) expr -> . - expr
    (48) expr -> . + expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . CHAR_LIT
    (51) expr -> . FLOAT_LIT
    (52) expr -> . INT_LIT
    (53) expr -> . BOOL_LIT
    (54) expr -> . IDENT . SIZE
    (55) expr -> . IDENT ( args )
    (56) expr -> . CONST
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . ! expr
    (60) expr -> . expr % expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (65) expr -> . expr > expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr < expr
    (68) expr -> . expr LE expr
    (69) expr -> . expr NE expr
    (70) expr -> . expr EQ expr
    (71) expr -> . expr AND expr
    (72) expr -> . expr OR expr
    (73) expr -> . location = expr
    (45) location -> . IDENT [ expr ]
    (46) location -> . IDENT
    -               shift and go to state 25
    +               shift and go to state 26
    NEW             shift and go to state 27
    CHAR_LIT        shift and go to state 28
    FLOAT_LIT       shift and go to state 29
    INT_LIT         shift and go to state 30
    BOOL_LIT        shift and go to state 31
    IDENT           shift and go to state 23
    CONST           shift and go to state 22
    (               shift and go to state 32
    !               shift and go to state 34

    expr                           shift and go to state 100
    location                       shift and go to state 33

state 90

    (58) expr -> ( expr ) .
    ;               reduce using rule 58 (expr -> ( expr ) .)
    %               reduce using rule 58 (expr -> ( expr ) .)
    /               reduce using rule 58 (expr -> ( expr ) .)
    *               reduce using rule 58 (expr -> ( expr ) .)
    -               reduce using rule 58 (expr -> ( expr ) .)
    +               reduce using rule 58 (expr -> ( expr ) .)
    >               reduce using rule 58 (expr -> ( expr ) .)
    GE              reduce using rule 58 (expr -> ( expr ) .)
    <               reduce using rule 58 (expr -> ( expr ) .)
    LE              reduce using rule 58 (expr -> ( expr ) .)
    NE              reduce using rule 58 (expr -> ( expr ) .)
    EQ              reduce using rule 58 (expr -> ( expr ) .)
    AND             reduce using rule 58 (expr -> ( expr ) .)
    OR              reduce using rule 58 (expr -> ( expr ) .)
    ]               reduce using rule 58 (expr -> ( expr ) .)
    )               reduce using rule 58 (expr -> ( expr ) .)
    ,               reduce using rule 58 (expr -> ( expr ) .)


state 91

    (73) expr -> location = expr .
    (60) expr -> expr . % expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    (65) expr -> expr . > expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . < expr
    (68) expr -> expr . LE expr
    (69) expr -> expr . NE expr
    (70) expr -> expr . EQ expr
    (71) expr -> expr . AND expr
    (72) expr -> expr . OR expr
    ;               reduce using rule 73 (expr -> location = expr .)
    ]               reduce using rule 73 (expr -> location = expr .)
    )               reduce using rule 73 (expr -> location = expr .)
    ,               reduce using rule 73 (expr -> location = expr .)
    %               shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    -               shift and go to state 49
    +               shift and go to state 50
    >               shift and go to state 51
    GE              shift and go to state 52
    <               shift and go to state 53
    LE              shift and go to state 54
    NE              shift and go to state 55
    EQ              shift and go to state 56
    AND             shift and go to state 57
    OR              shift and go to state 58


state 92

    (21) param -> type_spec IDENT [ . ]
    ]               shift and go to state 101


state 93

    (16) fun_decl -> type_spec IDENT ( params ) compound_stmt .
    CONST           reduce using rule 16 (fun_decl -> type_spec IDENT ( params ) compound_stmt .)
    CHAR            reduce using rule 16 (fun_decl -> type_spec IDENT ( params ) compound_stmt .)
    BOOL            reduce using rule 16 (fun_decl -> type_spec IDENT ( params ) compound_stmt .)
    FLOAT           reduce using rule 16 (fun_decl -> type_spec IDENT ( params ) compound_stmt .)
    INT             reduce using rule 16 (fun_decl -> type_spec IDENT ( params ) compound_stmt .)
    VOID            reduce using rule 16 (fun_decl -> type_spec IDENT ( params ) compound_stmt .)
    $end            reduce using rule 16 (fun_decl -> type_spec IDENT ( params ) compound_stmt .)


state 94

    (23) compound_stmt -> { . local_decls stmt_list }
    (24) local_decls -> . empty
    (25) local_decls -> . local_decls local_decl
    (78) empty -> .
    CHAR            reduce using rule 78 (empty -> .)
    BOOL            reduce using rule 78 (empty -> .)
    FLOAT           reduce using rule 78 (empty -> .)
    INT             reduce using rule 78 (empty -> .)
    VOID            reduce using rule 78 (empty -> .)
    }               reduce using rule 78 (empty -> .)
    BREAK           reduce using rule 78 (empty -> .)
    RETURN          reduce using rule 78 (empty -> .)
    WHILE           reduce using rule 78 (empty -> .)
    IF              reduce using rule 78 (empty -> .)
    {               reduce using rule 78 (empty -> .)
    ;               reduce using rule 78 (empty -> .)
    -               reduce using rule 78 (empty -> .)
    +               reduce using rule 78 (empty -> .)
    NEW             reduce using rule 78 (empty -> .)
    CHAR_LIT        reduce using rule 78 (empty -> .)
    FLOAT_LIT       reduce using rule 78 (empty -> .)
    INT_LIT         reduce using rule 78 (empty -> .)
    BOOL_LIT        reduce using rule 78 (empty -> .)
    IDENT           reduce using rule 78 (empty -> .)
    CONST           reduce using rule 78 (empty -> .)
    (               reduce using rule 78 (empty -> .)
    !               reduce using rule 78 (empty -> .)

    local_decls                    shift and go to state 102
    empty                          shift and go to state 103

state 95

    (20) param_list -> param_list , param .
    ,               reduce using rule 20 (param_list -> param_list , param .)
    )               reduce using rule 20 (param_list -> param_list , param .)


state 96

    (8) var_decl -> type_spec IDENT [ expr ] ; .
    CONST           reduce using rule 8 (var_decl -> type_spec IDENT [ expr ] ; .)
    CHAR            reduce using rule 8 (var_decl -> type_spec IDENT [ expr ] ; .)
    BOOL            reduce using rule 8 (var_decl -> type_spec IDENT [ expr ] ; .)
    FLOAT           reduce using rule 8 (var_decl -> type_spec IDENT [ expr ] ; .)
    INT             reduce using rule 8 (var_decl -> type_spec IDENT [ expr ] ; .)
    VOID            reduce using rule 8 (var_decl -> type_spec IDENT [ expr ] ; .)
    $end            reduce using rule 8 (var_decl -> type_spec IDENT [ expr ] ; .)


state 97

    (55) expr -> IDENT ( args ) .
    ;               reduce using rule 55 (expr -> IDENT ( args ) .)
    %               reduce using rule 55 (expr -> IDENT ( args ) .)
    /               reduce using rule 55 (expr -> IDENT ( args ) .)
    *               reduce using rule 55 (expr -> IDENT ( args ) .)
    -               reduce using rule 55 (expr -> IDENT ( args ) .)
    +               reduce using rule 55 (expr -> IDENT ( args ) .)
    >               reduce using rule 55 (expr -> IDENT ( args ) .)
    GE              reduce using rule 55 (expr -> IDENT ( args ) .)
    <               reduce using rule 55 (expr -> IDENT ( args ) .)
    LE              reduce using rule 55 (expr -> IDENT ( args ) .)
    NE              reduce using rule 55 (expr -> IDENT ( args ) .)
    EQ              reduce using rule 55 (expr -> IDENT ( args ) .)
    AND             reduce using rule 55 (expr -> IDENT ( args ) .)
    OR              reduce using rule 55 (expr -> IDENT ( args ) .)
    ]               reduce using rule 55 (expr -> IDENT ( args ) .)
    )               reduce using rule 55 (expr -> IDENT ( args ) .)
    ,               reduce using rule 55 (expr -> IDENT ( args ) .)


state 98

    (75) arg_list -> arg_list , . expr
    (47) expr -> . - expr
    (48) expr -> . + expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . CHAR_LIT
    (51) expr -> . FLOAT_LIT
    (52) expr -> . INT_LIT
    (53) expr -> . BOOL_LIT
    (54) expr -> . IDENT . SIZE
    (55) expr -> . IDENT ( args )
    (56) expr -> . CONST
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . ! expr
    (60) expr -> . expr % expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (65) expr -> . expr > expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr < expr
    (68) expr -> . expr LE expr
    (69) expr -> . expr NE expr
    (70) expr -> . expr EQ expr
    (71) expr -> . expr AND expr
    (72) expr -> . expr OR expr
    (73) expr -> . location = expr
    (45) location -> . IDENT [ expr ]
    (46) location -> . IDENT
    -               shift and go to state 25
    +               shift and go to state 26
    NEW             shift and go to state 27
    CHAR_LIT        shift and go to state 28
    FLOAT_LIT       shift and go to state 29
    INT_LIT         shift and go to state 30
    BOOL_LIT        shift and go to state 31
    IDENT           shift and go to state 23
    CONST           shift and go to state 22
    (               shift and go to state 32
    !               shift and go to state 34

    expr                           shift and go to state 104
    location                       shift and go to state 33

state 99

    (45) location -> IDENT [ expr ] .
    =               reduce using rule 45 (location -> IDENT [ expr ] .)
    ;               reduce using rule 45 (location -> IDENT [ expr ] .)
    %               reduce using rule 45 (location -> IDENT [ expr ] .)
    /               reduce using rule 45 (location -> IDENT [ expr ] .)
    *               reduce using rule 45 (location -> IDENT [ expr ] .)
    -               reduce using rule 45 (location -> IDENT [ expr ] .)
    +               reduce using rule 45 (location -> IDENT [ expr ] .)
    >               reduce using rule 45 (location -> IDENT [ expr ] .)
    GE              reduce using rule 45 (location -> IDENT [ expr ] .)
    <               reduce using rule 45 (location -> IDENT [ expr ] .)
    LE              reduce using rule 45 (location -> IDENT [ expr ] .)
    NE              reduce using rule 45 (location -> IDENT [ expr ] .)
    EQ              reduce using rule 45 (location -> IDENT [ expr ] .)
    AND             reduce using rule 45 (location -> IDENT [ expr ] .)
    OR              reduce using rule 45 (location -> IDENT [ expr ] .)
    ]               reduce using rule 45 (location -> IDENT [ expr ] .)
    )               reduce using rule 45 (location -> IDENT [ expr ] .)
    ,               reduce using rule 45 (location -> IDENT [ expr ] .)


state 100

    (49) expr -> NEW type_spec [ expr . ]
    (60) expr -> expr . % expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    (65) expr -> expr . > expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . < expr
    (68) expr -> expr . LE expr
    (69) expr -> expr . NE expr
    (70) expr -> expr . EQ expr
    (71) expr -> expr . AND expr
    (72) expr -> expr . OR expr
    ]               shift and go to state 105
    %               shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    -               shift and go to state 49
    +               shift and go to state 50
    >               shift and go to state 51
    GE              shift and go to state 52
    <               shift and go to state 53
    LE              shift and go to state 54
    NE              shift and go to state 55
    EQ              shift and go to state 56
    AND             shift and go to state 57
    OR              shift and go to state 58


state 101

    (21) param -> type_spec IDENT [ ] .
    ,               reduce using rule 21 (param -> type_spec IDENT [ ] .)
    )               reduce using rule 21 (param -> type_spec IDENT [ ] .)


state 102

    (23) compound_stmt -> { local_decls . stmt_list }
    (25) local_decls -> local_decls . local_decl
    (29) stmt_list -> . empty
    (30) stmt_list -> . stmt_list stmt
    (26) local_decl -> . type_spec IDENT = expr ;
    (27) local_decl -> . type_spec IDENT [ expr ] ;
    (28) local_decl -> . type_spec IDENT ;
    (78) empty -> .
    (11) type_spec -> . CHAR
    (12) type_spec -> . BOOL
    (13) type_spec -> . FLOAT
    (14) type_spec -> . INT
    (15) type_spec -> . VOID
    }               reduce using rule 78 (empty -> .)
    BREAK           reduce using rule 78 (empty -> .)
    RETURN          reduce using rule 78 (empty -> .)
    WHILE           reduce using rule 78 (empty -> .)
    IF              reduce using rule 78 (empty -> .)
    {               reduce using rule 78 (empty -> .)
    ;               reduce using rule 78 (empty -> .)
    -               reduce using rule 78 (empty -> .)
    +               reduce using rule 78 (empty -> .)
    NEW             reduce using rule 78 (empty -> .)
    CHAR_LIT        reduce using rule 78 (empty -> .)
    FLOAT_LIT       reduce using rule 78 (empty -> .)
    INT_LIT         reduce using rule 78 (empty -> .)
    BOOL_LIT        reduce using rule 78 (empty -> .)
    IDENT           reduce using rule 78 (empty -> .)
    CONST           reduce using rule 78 (empty -> .)
    (               reduce using rule 78 (empty -> .)
    !               reduce using rule 78 (empty -> .)
    CHAR            shift and go to state 9
    BOOL            shift and go to state 10
    FLOAT           shift and go to state 11
    INT             shift and go to state 12
    VOID            shift and go to state 13

    stmt_list                      shift and go to state 106
    local_decl                     shift and go to state 107
    empty                          shift and go to state 108
    type_spec                      shift and go to state 109

state 103

    (24) local_decls -> empty .
    CHAR            reduce using rule 24 (local_decls -> empty .)
    BOOL            reduce using rule 24 (local_decls -> empty .)
    FLOAT           reduce using rule 24 (local_decls -> empty .)
    INT             reduce using rule 24 (local_decls -> empty .)
    VOID            reduce using rule 24 (local_decls -> empty .)
    }               reduce using rule 24 (local_decls -> empty .)
    BREAK           reduce using rule 24 (local_decls -> empty .)
    RETURN          reduce using rule 24 (local_decls -> empty .)
    WHILE           reduce using rule 24 (local_decls -> empty .)
    IF              reduce using rule 24 (local_decls -> empty .)
    {               reduce using rule 24 (local_decls -> empty .)
    ;               reduce using rule 24 (local_decls -> empty .)
    -               reduce using rule 24 (local_decls -> empty .)
    +               reduce using rule 24 (local_decls -> empty .)
    NEW             reduce using rule 24 (local_decls -> empty .)
    CHAR_LIT        reduce using rule 24 (local_decls -> empty .)
    FLOAT_LIT       reduce using rule 24 (local_decls -> empty .)
    INT_LIT         reduce using rule 24 (local_decls -> empty .)
    BOOL_LIT        reduce using rule 24 (local_decls -> empty .)
    IDENT           reduce using rule 24 (local_decls -> empty .)
    CONST           reduce using rule 24 (local_decls -> empty .)
    (               reduce using rule 24 (local_decls -> empty .)
    !               reduce using rule 24 (local_decls -> empty .)


state 104

    (75) arg_list -> arg_list , expr .
    (60) expr -> expr . % expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    (65) expr -> expr . > expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . < expr
    (68) expr -> expr . LE expr
    (69) expr -> expr . NE expr
    (70) expr -> expr . EQ expr
    (71) expr -> expr . AND expr
    (72) expr -> expr . OR expr
    ,               reduce using rule 75 (arg_list -> arg_list , expr .)
    )               reduce using rule 75 (arg_list -> arg_list , expr .)
    %               shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    -               shift and go to state 49
    +               shift and go to state 50
    >               shift and go to state 51
    GE              shift and go to state 52
    <               shift and go to state 53
    LE              shift and go to state 54
    NE              shift and go to state 55
    EQ              shift and go to state 56
    AND             shift and go to state 57
    OR              shift and go to state 58


state 105

    (49) expr -> NEW type_spec [ expr ] .
    ;               reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    %               reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    /               reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    *               reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    -               reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    +               reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    >               reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    GE              reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    <               reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    LE              reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    NE              reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    EQ              reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    AND             reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    OR              reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    ]               reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    )               reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    ,               reduce using rule 49 (expr -> NEW type_spec [ expr ] .)


state 106

    (23) compound_stmt -> { local_decls stmt_list . }
    (30) stmt_list -> stmt_list . stmt
    (31) stmt -> . break_stmt
    (32) stmt -> . return_stmt
    (33) stmt -> . while_stmt
    (34) stmt -> . if_stmt
    (35) stmt -> . compound_stmt
    (36) stmt -> . expr_stmt
    (44) break_stmt -> . BREAK
    (42) return_stmt -> . RETURN expr ;
    (43) return_stmt -> . RETURN ;
    (39) while_stmt -> . WHILE ( expr ) stmt
    (40) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (41) if_stmt -> . IF ( expr ) stmt
    (23) compound_stmt -> . { local_decls stmt_list }
    (37) expr_stmt -> . ;
    (38) expr_stmt -> . expr ;
    (47) expr -> . - expr
    (48) expr -> . + expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . CHAR_LIT
    (51) expr -> . FLOAT_LIT
    (52) expr -> . INT_LIT
    (53) expr -> . BOOL_LIT
    (54) expr -> . IDENT . SIZE
    (55) expr -> . IDENT ( args )
    (56) expr -> . CONST
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . ! expr
    (60) expr -> . expr % expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (65) expr -> . expr > expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr < expr
    (68) expr -> . expr LE expr
    (69) expr -> . expr NE expr
    (70) expr -> . expr EQ expr
    (71) expr -> . expr AND expr
    (72) expr -> . expr OR expr
    (73) expr -> . location = expr
    (45) location -> . IDENT [ expr ]
    (46) location -> . IDENT
    }               shift and go to state 110
    BREAK           shift and go to state 118
    RETURN          shift and go to state 119
    WHILE           shift and go to state 122
    IF              shift and go to state 123
    {               shift and go to state 94
    ;               shift and go to state 121
    -               shift and go to state 25
    +               shift and go to state 26
    NEW             shift and go to state 27
    CHAR_LIT        shift and go to state 28
    FLOAT_LIT       shift and go to state 29
    INT_LIT         shift and go to state 30
    BOOL_LIT        shift and go to state 31
    IDENT           shift and go to state 23
    CONST           shift and go to state 22
    (               shift and go to state 32
    !               shift and go to state 34

    stmt                           shift and go to state 111
    break_stmt                     shift and go to state 112
    return_stmt                    shift and go to state 113
    while_stmt                     shift and go to state 114
    if_stmt                        shift and go to state 115
    compound_stmt                  shift and go to state 116
    expr_stmt                      shift and go to state 117
    expr                           shift and go to state 120
    location                       shift and go to state 33

state 107

    (25) local_decls -> local_decls local_decl .
    CHAR            reduce using rule 25 (local_decls -> local_decls local_decl .)
    BOOL            reduce using rule 25 (local_decls -> local_decls local_decl .)
    FLOAT           reduce using rule 25 (local_decls -> local_decls local_decl .)
    INT             reduce using rule 25 (local_decls -> local_decls local_decl .)
    VOID            reduce using rule 25 (local_decls -> local_decls local_decl .)
    }               reduce using rule 25 (local_decls -> local_decls local_decl .)
    BREAK           reduce using rule 25 (local_decls -> local_decls local_decl .)
    RETURN          reduce using rule 25 (local_decls -> local_decls local_decl .)
    WHILE           reduce using rule 25 (local_decls -> local_decls local_decl .)
    IF              reduce using rule 25 (local_decls -> local_decls local_decl .)
    {               reduce using rule 25 (local_decls -> local_decls local_decl .)
    ;               reduce using rule 25 (local_decls -> local_decls local_decl .)
    -               reduce using rule 25 (local_decls -> local_decls local_decl .)
    +               reduce using rule 25 (local_decls -> local_decls local_decl .)
    NEW             reduce using rule 25 (local_decls -> local_decls local_decl .)
    CHAR_LIT        reduce using rule 25 (local_decls -> local_decls local_decl .)
    FLOAT_LIT       reduce using rule 25 (local_decls -> local_decls local_decl .)
    INT_LIT         reduce using rule 25 (local_decls -> local_decls local_decl .)
    BOOL_LIT        reduce using rule 25 (local_decls -> local_decls local_decl .)
    IDENT           reduce using rule 25 (local_decls -> local_decls local_decl .)
    CONST           reduce using rule 25 (local_decls -> local_decls local_decl .)
    (               reduce using rule 25 (local_decls -> local_decls local_decl .)
    !               reduce using rule 25 (local_decls -> local_decls local_decl .)


state 108

    (29) stmt_list -> empty .
    }               reduce using rule 29 (stmt_list -> empty .)
    BREAK           reduce using rule 29 (stmt_list -> empty .)
    RETURN          reduce using rule 29 (stmt_list -> empty .)
    WHILE           reduce using rule 29 (stmt_list -> empty .)
    IF              reduce using rule 29 (stmt_list -> empty .)
    {               reduce using rule 29 (stmt_list -> empty .)
    ;               reduce using rule 29 (stmt_list -> empty .)
    -               reduce using rule 29 (stmt_list -> empty .)
    +               reduce using rule 29 (stmt_list -> empty .)
    NEW             reduce using rule 29 (stmt_list -> empty .)
    CHAR_LIT        reduce using rule 29 (stmt_list -> empty .)
    FLOAT_LIT       reduce using rule 29 (stmt_list -> empty .)
    INT_LIT         reduce using rule 29 (stmt_list -> empty .)
    BOOL_LIT        reduce using rule 29 (stmt_list -> empty .)
    IDENT           reduce using rule 29 (stmt_list -> empty .)
    CONST           reduce using rule 29 (stmt_list -> empty .)
    (               reduce using rule 29 (stmt_list -> empty .)
    !               reduce using rule 29 (stmt_list -> empty .)


state 109

    (26) local_decl -> type_spec . IDENT = expr ;
    (27) local_decl -> type_spec . IDENT [ expr ] ;
    (28) local_decl -> type_spec . IDENT ;
    IDENT           shift and go to state 124


state 110

    (23) compound_stmt -> { local_decls stmt_list } .
    CONST           reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    CHAR            reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    BOOL            reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    FLOAT           reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    INT             reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    VOID            reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    $end            reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    }               reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    BREAK           reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    RETURN          reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    WHILE           reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    IF              reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    {               reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    ;               reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    -               reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    +               reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    NEW             reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    CHAR_LIT        reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    FLOAT_LIT       reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    INT_LIT         reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    BOOL_LIT        reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    IDENT           reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    (               reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    !               reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    ELSE            reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)


state 111

    (30) stmt_list -> stmt_list stmt .
    }               reduce using rule 30 (stmt_list -> stmt_list stmt .)
    BREAK           reduce using rule 30 (stmt_list -> stmt_list stmt .)
    RETURN          reduce using rule 30 (stmt_list -> stmt_list stmt .)
    WHILE           reduce using rule 30 (stmt_list -> stmt_list stmt .)
    IF              reduce using rule 30 (stmt_list -> stmt_list stmt .)
    {               reduce using rule 30 (stmt_list -> stmt_list stmt .)
    ;               reduce using rule 30 (stmt_list -> stmt_list stmt .)
    -               reduce using rule 30 (stmt_list -> stmt_list stmt .)
    +               reduce using rule 30 (stmt_list -> stmt_list stmt .)
    NEW             reduce using rule 30 (stmt_list -> stmt_list stmt .)
    CHAR_LIT        reduce using rule 30 (stmt_list -> stmt_list stmt .)
    FLOAT_LIT       reduce using rule 30 (stmt_list -> stmt_list stmt .)
    INT_LIT         reduce using rule 30 (stmt_list -> stmt_list stmt .)
    BOOL_LIT        reduce using rule 30 (stmt_list -> stmt_list stmt .)
    IDENT           reduce using rule 30 (stmt_list -> stmt_list stmt .)
    CONST           reduce using rule 30 (stmt_list -> stmt_list stmt .)
    (               reduce using rule 30 (stmt_list -> stmt_list stmt .)
    !               reduce using rule 30 (stmt_list -> stmt_list stmt .)


state 112

    (31) stmt -> break_stmt .
    }               reduce using rule 31 (stmt -> break_stmt .)
    BREAK           reduce using rule 31 (stmt -> break_stmt .)
    RETURN          reduce using rule 31 (stmt -> break_stmt .)
    WHILE           reduce using rule 31 (stmt -> break_stmt .)
    IF              reduce using rule 31 (stmt -> break_stmt .)
    {               reduce using rule 31 (stmt -> break_stmt .)
    ;               reduce using rule 31 (stmt -> break_stmt .)
    -               reduce using rule 31 (stmt -> break_stmt .)
    +               reduce using rule 31 (stmt -> break_stmt .)
    NEW             reduce using rule 31 (stmt -> break_stmt .)
    CHAR_LIT        reduce using rule 31 (stmt -> break_stmt .)
    FLOAT_LIT       reduce using rule 31 (stmt -> break_stmt .)
    INT_LIT         reduce using rule 31 (stmt -> break_stmt .)
    BOOL_LIT        reduce using rule 31 (stmt -> break_stmt .)
    IDENT           reduce using rule 31 (stmt -> break_stmt .)
    CONST           reduce using rule 31 (stmt -> break_stmt .)
    (               reduce using rule 31 (stmt -> break_stmt .)
    !               reduce using rule 31 (stmt -> break_stmt .)
    ELSE            reduce using rule 31 (stmt -> break_stmt .)


state 113

    (32) stmt -> return_stmt .
    }               reduce using rule 32 (stmt -> return_stmt .)
    BREAK           reduce using rule 32 (stmt -> return_stmt .)
    RETURN          reduce using rule 32 (stmt -> return_stmt .)
    WHILE           reduce using rule 32 (stmt -> return_stmt .)
    IF              reduce using rule 32 (stmt -> return_stmt .)
    {               reduce using rule 32 (stmt -> return_stmt .)
    ;               reduce using rule 32 (stmt -> return_stmt .)
    -               reduce using rule 32 (stmt -> return_stmt .)
    +               reduce using rule 32 (stmt -> return_stmt .)
    NEW             reduce using rule 32 (stmt -> return_stmt .)
    CHAR_LIT        reduce using rule 32 (stmt -> return_stmt .)
    FLOAT_LIT       reduce using rule 32 (stmt -> return_stmt .)
    INT_LIT         reduce using rule 32 (stmt -> return_stmt .)
    BOOL_LIT        reduce using rule 32 (stmt -> return_stmt .)
    IDENT           reduce using rule 32 (stmt -> return_stmt .)
    CONST           reduce using rule 32 (stmt -> return_stmt .)
    (               reduce using rule 32 (stmt -> return_stmt .)
    !               reduce using rule 32 (stmt -> return_stmt .)
    ELSE            reduce using rule 32 (stmt -> return_stmt .)


state 114

    (33) stmt -> while_stmt .
    }               reduce using rule 33 (stmt -> while_stmt .)
    BREAK           reduce using rule 33 (stmt -> while_stmt .)
    RETURN          reduce using rule 33 (stmt -> while_stmt .)
    WHILE           reduce using rule 33 (stmt -> while_stmt .)
    IF              reduce using rule 33 (stmt -> while_stmt .)
    {               reduce using rule 33 (stmt -> while_stmt .)
    ;               reduce using rule 33 (stmt -> while_stmt .)
    -               reduce using rule 33 (stmt -> while_stmt .)
    +               reduce using rule 33 (stmt -> while_stmt .)
    NEW             reduce using rule 33 (stmt -> while_stmt .)
    CHAR_LIT        reduce using rule 33 (stmt -> while_stmt .)
    FLOAT_LIT       reduce using rule 33 (stmt -> while_stmt .)
    INT_LIT         reduce using rule 33 (stmt -> while_stmt .)
    BOOL_LIT        reduce using rule 33 (stmt -> while_stmt .)
    IDENT           reduce using rule 33 (stmt -> while_stmt .)
    CONST           reduce using rule 33 (stmt -> while_stmt .)
    (               reduce using rule 33 (stmt -> while_stmt .)
    !               reduce using rule 33 (stmt -> while_stmt .)
    ELSE            reduce using rule 33 (stmt -> while_stmt .)


state 115

    (34) stmt -> if_stmt .
    }               reduce using rule 34 (stmt -> if_stmt .)
    BREAK           reduce using rule 34 (stmt -> if_stmt .)
    RETURN          reduce using rule 34 (stmt -> if_stmt .)
    WHILE           reduce using rule 34 (stmt -> if_stmt .)
    IF              reduce using rule 34 (stmt -> if_stmt .)
    {               reduce using rule 34 (stmt -> if_stmt .)
    ;               reduce using rule 34 (stmt -> if_stmt .)
    -               reduce using rule 34 (stmt -> if_stmt .)
    +               reduce using rule 34 (stmt -> if_stmt .)
    NEW             reduce using rule 34 (stmt -> if_stmt .)
    CHAR_LIT        reduce using rule 34 (stmt -> if_stmt .)
    FLOAT_LIT       reduce using rule 34 (stmt -> if_stmt .)
    INT_LIT         reduce using rule 34 (stmt -> if_stmt .)
    BOOL_LIT        reduce using rule 34 (stmt -> if_stmt .)
    IDENT           reduce using rule 34 (stmt -> if_stmt .)
    CONST           reduce using rule 34 (stmt -> if_stmt .)
    (               reduce using rule 34 (stmt -> if_stmt .)
    !               reduce using rule 34 (stmt -> if_stmt .)
    ELSE            reduce using rule 34 (stmt -> if_stmt .)


state 116

    (35) stmt -> compound_stmt .
    }               reduce using rule 35 (stmt -> compound_stmt .)
    BREAK           reduce using rule 35 (stmt -> compound_stmt .)
    RETURN          reduce using rule 35 (stmt -> compound_stmt .)
    WHILE           reduce using rule 35 (stmt -> compound_stmt .)
    IF              reduce using rule 35 (stmt -> compound_stmt .)
    {               reduce using rule 35 (stmt -> compound_stmt .)
    ;               reduce using rule 35 (stmt -> compound_stmt .)
    -               reduce using rule 35 (stmt -> compound_stmt .)
    +               reduce using rule 35 (stmt -> compound_stmt .)
    NEW             reduce using rule 35 (stmt -> compound_stmt .)
    CHAR_LIT        reduce using rule 35 (stmt -> compound_stmt .)
    FLOAT_LIT       reduce using rule 35 (stmt -> compound_stmt .)
    INT_LIT         reduce using rule 35 (stmt -> compound_stmt .)
    BOOL_LIT        reduce using rule 35 (stmt -> compound_stmt .)
    IDENT           reduce using rule 35 (stmt -> compound_stmt .)
    CONST           reduce using rule 35 (stmt -> compound_stmt .)
    (               reduce using rule 35 (stmt -> compound_stmt .)
    !               reduce using rule 35 (stmt -> compound_stmt .)
    ELSE            reduce using rule 35 (stmt -> compound_stmt .)


state 117

    (36) stmt -> expr_stmt .
    }               reduce using rule 36 (stmt -> expr_stmt .)
    BREAK           reduce using rule 36 (stmt -> expr_stmt .)
    RETURN          reduce using rule 36 (stmt -> expr_stmt .)
    WHILE           reduce using rule 36 (stmt -> expr_stmt .)
    IF              reduce using rule 36 (stmt -> expr_stmt .)
    {               reduce using rule 36 (stmt -> expr_stmt .)
    ;               reduce using rule 36 (stmt -> expr_stmt .)
    -               reduce using rule 36 (stmt -> expr_stmt .)
    +               reduce using rule 36 (stmt -> expr_stmt .)
    NEW             reduce using rule 36 (stmt -> expr_stmt .)
    CHAR_LIT        reduce using rule 36 (stmt -> expr_stmt .)
    FLOAT_LIT       reduce using rule 36 (stmt -> expr_stmt .)
    INT_LIT         reduce using rule 36 (stmt -> expr_stmt .)
    BOOL_LIT        reduce using rule 36 (stmt -> expr_stmt .)
    IDENT           reduce using rule 36 (stmt -> expr_stmt .)
    CONST           reduce using rule 36 (stmt -> expr_stmt .)
    (               reduce using rule 36 (stmt -> expr_stmt .)
    !               reduce using rule 36 (stmt -> expr_stmt .)
    ELSE            reduce using rule 36 (stmt -> expr_stmt .)


state 118

    (44) break_stmt -> BREAK .
    }               reduce using rule 44 (break_stmt -> BREAK .)
    BREAK           reduce using rule 44 (break_stmt -> BREAK .)
    RETURN          reduce using rule 44 (break_stmt -> BREAK .)
    WHILE           reduce using rule 44 (break_stmt -> BREAK .)
    IF              reduce using rule 44 (break_stmt -> BREAK .)
    {               reduce using rule 44 (break_stmt -> BREAK .)
    ;               reduce using rule 44 (break_stmt -> BREAK .)
    -               reduce using rule 44 (break_stmt -> BREAK .)
    +               reduce using rule 44 (break_stmt -> BREAK .)
    NEW             reduce using rule 44 (break_stmt -> BREAK .)
    CHAR_LIT        reduce using rule 44 (break_stmt -> BREAK .)
    FLOAT_LIT       reduce using rule 44 (break_stmt -> BREAK .)
    INT_LIT         reduce using rule 44 (break_stmt -> BREAK .)
    BOOL_LIT        reduce using rule 44 (break_stmt -> BREAK .)
    IDENT           reduce using rule 44 (break_stmt -> BREAK .)
    CONST           reduce using rule 44 (break_stmt -> BREAK .)
    (               reduce using rule 44 (break_stmt -> BREAK .)
    !               reduce using rule 44 (break_stmt -> BREAK .)
    ELSE            reduce using rule 44 (break_stmt -> BREAK .)


state 119

    (42) return_stmt -> RETURN . expr ;
    (43) return_stmt -> RETURN . ;
    (47) expr -> . - expr
    (48) expr -> . + expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . CHAR_LIT
    (51) expr -> . FLOAT_LIT
    (52) expr -> . INT_LIT
    (53) expr -> . BOOL_LIT
    (54) expr -> . IDENT . SIZE
    (55) expr -> . IDENT ( args )
    (56) expr -> . CONST
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . ! expr
    (60) expr -> . expr % expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (65) expr -> . expr > expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr < expr
    (68) expr -> . expr LE expr
    (69) expr -> . expr NE expr
    (70) expr -> . expr EQ expr
    (71) expr -> . expr AND expr
    (72) expr -> . expr OR expr
    (73) expr -> . location = expr
    (45) location -> . IDENT [ expr ]
    (46) location -> . IDENT
    ;               shift and go to state 126
    -               shift and go to state 25
    +               shift and go to state 26
    NEW             shift and go to state 27
    CHAR_LIT        shift and go to state 28
    FLOAT_LIT       shift and go to state 29
    INT_LIT         shift and go to state 30
    BOOL_LIT        shift and go to state 31
    IDENT           shift and go to state 23
    CONST           shift and go to state 22
    (               shift and go to state 32
    !               shift and go to state 34

    expr                           shift and go to state 125
    location                       shift and go to state 33

state 120

    (38) expr_stmt -> expr . ;
    (60) expr -> expr . % expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    (65) expr -> expr . > expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . < expr
    (68) expr -> expr . LE expr
    (69) expr -> expr . NE expr
    (70) expr -> expr . EQ expr
    (71) expr -> expr . AND expr
    (72) expr -> expr . OR expr
    ;               shift and go to state 127
    %               shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    -               shift and go to state 49
    +               shift and go to state 50
    >               shift and go to state 51
    GE              shift and go to state 52
    <               shift and go to state 53
    LE              shift and go to state 54
    NE              shift and go to state 55
    EQ              shift and go to state 56
    AND             shift and go to state 57
    OR              shift and go to state 58


state 121

    (37) expr_stmt -> ; .
    }               reduce using rule 37 (expr_stmt -> ; .)
    BREAK           reduce using rule 37 (expr_stmt -> ; .)
    RETURN          reduce using rule 37 (expr_stmt -> ; .)
    WHILE           reduce using rule 37 (expr_stmt -> ; .)
    IF              reduce using rule 37 (expr_stmt -> ; .)
    {               reduce using rule 37 (expr_stmt -> ; .)
    ;               reduce using rule 37 (expr_stmt -> ; .)
    -               reduce using rule 37 (expr_stmt -> ; .)
    +               reduce using rule 37 (expr_stmt -> ; .)
    NEW             reduce using rule 37 (expr_stmt -> ; .)
    CHAR_LIT        reduce using rule 37 (expr_stmt -> ; .)
    FLOAT_LIT       reduce using rule 37 (expr_stmt -> ; .)
    INT_LIT         reduce using rule 37 (expr_stmt -> ; .)
    BOOL_LIT        reduce using rule 37 (expr_stmt -> ; .)
    IDENT           reduce using rule 37 (expr_stmt -> ; .)
    CONST           reduce using rule 37 (expr_stmt -> ; .)
    (               reduce using rule 37 (expr_stmt -> ; .)
    !               reduce using rule 37 (expr_stmt -> ; .)
    ELSE            reduce using rule 37 (expr_stmt -> ; .)


state 122

    (39) while_stmt -> WHILE . ( expr ) stmt
    (               shift and go to state 128


state 123

    (40) if_stmt -> IF . ( expr ) stmt ELSE stmt
    (41) if_stmt -> IF . ( expr ) stmt
    (               shift and go to state 129


state 124

    (26) local_decl -> type_spec IDENT . = expr ;
    (27) local_decl -> type_spec IDENT . [ expr ] ;
    (28) local_decl -> type_spec IDENT . ;
    =               shift and go to state 130
    [               shift and go to state 132
    ;               shift and go to state 131


state 125

    (42) return_stmt -> RETURN expr . ;
    (60) expr -> expr . % expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    (65) expr -> expr . > expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . < expr
    (68) expr -> expr . LE expr
    (69) expr -> expr . NE expr
    (70) expr -> expr . EQ expr
    (71) expr -> expr . AND expr
    (72) expr -> expr . OR expr
    ;               shift and go to state 133
    %               shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    -               shift and go to state 49
    +               shift and go to state 50
    >               shift and go to state 51
    GE              shift and go to state 52
    <               shift and go to state 53
    LE              shift and go to state 54
    NE              shift and go to state 55
    EQ              shift and go to state 56
    AND             shift and go to state 57
    OR              shift and go to state 58


state 126

    (43) return_stmt -> RETURN ; .
    }               reduce using rule 43 (return_stmt -> RETURN ; .)
    BREAK           reduce using rule 43 (return_stmt -> RETURN ; .)
    RETURN          reduce using rule 43 (return_stmt -> RETURN ; .)
    WHILE           reduce using rule 43 (return_stmt -> RETURN ; .)
    IF              reduce using rule 43 (return_stmt -> RETURN ; .)
    {               reduce using rule 43 (return_stmt -> RETURN ; .)
    ;               reduce using rule 43 (return_stmt -> RETURN ; .)
    -               reduce using rule 43 (return_stmt -> RETURN ; .)
    +               reduce using rule 43 (return_stmt -> RETURN ; .)
    NEW             reduce using rule 43 (return_stmt -> RETURN ; .)
    CHAR_LIT        reduce using rule 43 (return_stmt -> RETURN ; .)
    FLOAT_LIT       reduce using rule 43 (return_stmt -> RETURN ; .)
    INT_LIT         reduce using rule 43 (return_stmt -> RETURN ; .)
    BOOL_LIT        reduce using rule 43 (return_stmt -> RETURN ; .)
    IDENT           reduce using rule 43 (return_stmt -> RETURN ; .)
    CONST           reduce using rule 43 (return_stmt -> RETURN ; .)
    (               reduce using rule 43 (return_stmt -> RETURN ; .)
    !               reduce using rule 43 (return_stmt -> RETURN ; .)
    ELSE            reduce using rule 43 (return_stmt -> RETURN ; .)


state 127

    (38) expr_stmt -> expr ; .
    }               reduce using rule 38 (expr_stmt -> expr ; .)
    BREAK           reduce using rule 38 (expr_stmt -> expr ; .)
    RETURN          reduce using rule 38 (expr_stmt -> expr ; .)
    WHILE           reduce using rule 38 (expr_stmt -> expr ; .)
    IF              reduce using rule 38 (expr_stmt -> expr ; .)
    {               reduce using rule 38 (expr_stmt -> expr ; .)
    ;               reduce using rule 38 (expr_stmt -> expr ; .)
    -               reduce using rule 38 (expr_stmt -> expr ; .)
    +               reduce using rule 38 (expr_stmt -> expr ; .)
    NEW             reduce using rule 38 (expr_stmt -> expr ; .)
    CHAR_LIT        reduce using rule 38 (expr_stmt -> expr ; .)
    FLOAT_LIT       reduce using rule 38 (expr_stmt -> expr ; .)
    INT_LIT         reduce using rule 38 (expr_stmt -> expr ; .)
    BOOL_LIT        reduce using rule 38 (expr_stmt -> expr ; .)
    IDENT           reduce using rule 38 (expr_stmt -> expr ; .)
    CONST           reduce using rule 38 (expr_stmt -> expr ; .)
    (               reduce using rule 38 (expr_stmt -> expr ; .)
    !               reduce using rule 38 (expr_stmt -> expr ; .)
    ELSE            reduce using rule 38 (expr_stmt -> expr ; .)


state 128

    (39) while_stmt -> WHILE ( . expr ) stmt
    (47) expr -> . - expr
    (48) expr -> . + expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . CHAR_LIT
    (51) expr -> . FLOAT_LIT
    (52) expr -> . INT_LIT
    (53) expr -> . BOOL_LIT
    (54) expr -> . IDENT . SIZE
    (55) expr -> . IDENT ( args )
    (56) expr -> . CONST
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . ! expr
    (60) expr -> . expr % expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (65) expr -> . expr > expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr < expr
    (68) expr -> . expr LE expr
    (69) expr -> . expr NE expr
    (70) expr -> . expr EQ expr
    (71) expr -> . expr AND expr
    (72) expr -> . expr OR expr
    (73) expr -> . location = expr
    (45) location -> . IDENT [ expr ]
    (46) location -> . IDENT
    -               shift and go to state 25
    +               shift and go to state 26
    NEW             shift and go to state 27
    CHAR_LIT        shift and go to state 28
    FLOAT_LIT       shift and go to state 29
    INT_LIT         shift and go to state 30
    BOOL_LIT        shift and go to state 31
    IDENT           shift and go to state 23
    CONST           shift and go to state 22
    (               shift and go to state 32
    !               shift and go to state 34

    expr                           shift and go to state 134
    location                       shift and go to state 33

state 129

    (40) if_stmt -> IF ( . expr ) stmt ELSE stmt
    (41) if_stmt -> IF ( . expr ) stmt
    (47) expr -> . - expr
    (48) expr -> . + expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . CHAR_LIT
    (51) expr -> . FLOAT_LIT
    (52) expr -> . INT_LIT
    (53) expr -> . BOOL_LIT
    (54) expr -> . IDENT . SIZE
    (55) expr -> . IDENT ( args )
    (56) expr -> . CONST
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . ! expr
    (60) expr -> . expr % expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (65) expr -> . expr > expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr < expr
    (68) expr -> . expr LE expr
    (69) expr -> . expr NE expr
    (70) expr -> . expr EQ expr
    (71) expr -> . expr AND expr
    (72) expr -> . expr OR expr
    (73) expr -> . location = expr
    (45) location -> . IDENT [ expr ]
    (46) location -> . IDENT
    -               shift and go to state 25
    +               shift and go to state 26
    NEW             shift and go to state 27
    CHAR_LIT        shift and go to state 28
    FLOAT_LIT       shift and go to state 29
    INT_LIT         shift and go to state 30
    BOOL_LIT        shift and go to state 31
    IDENT           shift and go to state 23
    CONST           shift and go to state 22
    (               shift and go to state 32
    !               shift and go to state 34

    expr                           shift and go to state 135
    location                       shift and go to state 33

state 130

    (26) local_decl -> type_spec IDENT = . expr ;
    (47) expr -> . - expr
    (48) expr -> . + expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . CHAR_LIT
    (51) expr -> . FLOAT_LIT
    (52) expr -> . INT_LIT
    (53) expr -> . BOOL_LIT
    (54) expr -> . IDENT . SIZE
    (55) expr -> . IDENT ( args )
    (56) expr -> . CONST
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . ! expr
    (60) expr -> . expr % expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (65) expr -> . expr > expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr < expr
    (68) expr -> . expr LE expr
    (69) expr -> . expr NE expr
    (70) expr -> . expr EQ expr
    (71) expr -> . expr AND expr
    (72) expr -> . expr OR expr
    (73) expr -> . location = expr
    (45) location -> . IDENT [ expr ]
    (46) location -> . IDENT
    -               shift and go to state 25
    +               shift and go to state 26
    NEW             shift and go to state 27
    CHAR_LIT        shift and go to state 28
    FLOAT_LIT       shift and go to state 29
    INT_LIT         shift and go to state 30
    BOOL_LIT        shift and go to state 31
    IDENT           shift and go to state 23
    CONST           shift and go to state 22
    (               shift and go to state 32
    !               shift and go to state 34

    expr                           shift and go to state 136
    location                       shift and go to state 33

state 131

    (28) local_decl -> type_spec IDENT ; .
    CHAR            reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    BOOL            reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    FLOAT           reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    INT             reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    VOID            reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    }               reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    BREAK           reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    RETURN          reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    WHILE           reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    IF              reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    {               reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    ;               reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    -               reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    +               reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    NEW             reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    CHAR_LIT        reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    FLOAT_LIT       reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    INT_LIT         reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    BOOL_LIT        reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    IDENT           reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    CONST           reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    (               reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    !               reduce using rule 28 (local_decl -> type_spec IDENT ; .)


state 132

    (27) local_decl -> type_spec IDENT [ . expr ] ;
    (47) expr -> . - expr
    (48) expr -> . + expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . CHAR_LIT
    (51) expr -> . FLOAT_LIT
    (52) expr -> . INT_LIT
    (53) expr -> . BOOL_LIT
    (54) expr -> . IDENT . SIZE
    (55) expr -> . IDENT ( args )
    (56) expr -> . CONST
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . ! expr
    (60) expr -> . expr % expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (65) expr -> . expr > expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr < expr
    (68) expr -> . expr LE expr
    (69) expr -> . expr NE expr
    (70) expr -> . expr EQ expr
    (71) expr -> . expr AND expr
    (72) expr -> . expr OR expr
    (73) expr -> . location = expr
    (45) location -> . IDENT [ expr ]
    (46) location -> . IDENT
    -               shift and go to state 25
    +               shift and go to state 26
    NEW             shift and go to state 27
    CHAR_LIT        shift and go to state 28
    FLOAT_LIT       shift and go to state 29
    INT_LIT         shift and go to state 30
    BOOL_LIT        shift and go to state 31
    IDENT           shift and go to state 23
    CONST           shift and go to state 22
    (               shift and go to state 32
    !               shift and go to state 34

    expr                           shift and go to state 137
    location                       shift and go to state 33

state 133

    (42) return_stmt -> RETURN expr ; .
    }               reduce using rule 42 (return_stmt -> RETURN expr ; .)
    BREAK           reduce using rule 42 (return_stmt -> RETURN expr ; .)
    RETURN          reduce using rule 42 (return_stmt -> RETURN expr ; .)
    WHILE           reduce using rule 42 (return_stmt -> RETURN expr ; .)
    IF              reduce using rule 42 (return_stmt -> RETURN expr ; .)
    {               reduce using rule 42 (return_stmt -> RETURN expr ; .)
    ;               reduce using rule 42 (return_stmt -> RETURN expr ; .)
    -               reduce using rule 42 (return_stmt -> RETURN expr ; .)
    +               reduce using rule 42 (return_stmt -> RETURN expr ; .)
    NEW             reduce using rule 42 (return_stmt -> RETURN expr ; .)
    CHAR_LIT        reduce using rule 42 (return_stmt -> RETURN expr ; .)
    FLOAT_LIT       reduce using rule 42 (return_stmt -> RETURN expr ; .)
    INT_LIT         reduce using rule 42 (return_stmt -> RETURN expr ; .)
    BOOL_LIT        reduce using rule 42 (return_stmt -> RETURN expr ; .)
    IDENT           reduce using rule 42 (return_stmt -> RETURN expr ; .)
    CONST           reduce using rule 42 (return_stmt -> RETURN expr ; .)
    (               reduce using rule 42 (return_stmt -> RETURN expr ; .)
    !               reduce using rule 42 (return_stmt -> RETURN expr ; .)
    ELSE            reduce using rule 42 (return_stmt -> RETURN expr ; .)


state 134

    (39) while_stmt -> WHILE ( expr . ) stmt
    (60) expr -> expr . % expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    (65) expr -> expr . > expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . < expr
    (68) expr -> expr . LE expr
    (69) expr -> expr . NE expr
    (70) expr -> expr . EQ expr
    (71) expr -> expr . AND expr
    (72) expr -> expr . OR expr
    )               shift and go to state 138
    %               shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    -               shift and go to state 49
    +               shift and go to state 50
    >               shift and go to state 51
    GE              shift and go to state 52
    <               shift and go to state 53
    LE              shift and go to state 54
    NE              shift and go to state 55
    EQ              shift and go to state 56
    AND             shift and go to state 57
    OR              shift and go to state 58


state 135

    (40) if_stmt -> IF ( expr . ) stmt ELSE stmt
    (41) if_stmt -> IF ( expr . ) stmt
    (60) expr -> expr . % expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    (65) expr -> expr . > expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . < expr
    (68) expr -> expr . LE expr
    (69) expr -> expr . NE expr
    (70) expr -> expr . EQ expr
    (71) expr -> expr . AND expr
    (72) expr -> expr . OR expr
    )               shift and go to state 139
    %               shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    -               shift and go to state 49
    +               shift and go to state 50
    >               shift and go to state 51
    GE              shift and go to state 52
    <               shift and go to state 53
    LE              shift and go to state 54
    NE              shift and go to state 55
    EQ              shift and go to state 56
    AND             shift and go to state 57
    OR              shift and go to state 58


state 136

    (26) local_decl -> type_spec IDENT = expr . ;
    (60) expr -> expr . % expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    (65) expr -> expr . > expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . < expr
    (68) expr -> expr . LE expr
    (69) expr -> expr . NE expr
    (70) expr -> expr . EQ expr
    (71) expr -> expr . AND expr
    (72) expr -> expr . OR expr
    ;               shift and go to state 140
    %               shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    -               shift and go to state 49
    +               shift and go to state 50
    >               shift and go to state 51
    GE              shift and go to state 52
    <               shift and go to state 53
    LE              shift and go to state 54
    NE              shift and go to state 55
    EQ              shift and go to state 56
    AND             shift and go to state 57
    OR              shift and go to state 58


state 137

    (27) local_decl -> type_spec IDENT [ expr . ] ;
    (60) expr -> expr . % expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    (65) expr -> expr . > expr
    (66) expr -> expr . GE expr
    (67) expr -> expr . < expr
    (68) expr -> expr . LE expr
    (69) expr -> expr . NE expr
    (70) expr -> expr . EQ expr
    (71) expr -> expr . AND expr
    (72) expr -> expr . OR expr
    ]               shift and go to state 141
    %               shift and go to state 46
    /               shift and go to state 47
    *               shift and go to state 48
    -               shift and go to state 49
    +               shift and go to state 50
    >               shift and go to state 51
    GE              shift and go to state 52
    <               shift and go to state 53
    LE              shift and go to state 54
    NE              shift and go to state 55
    EQ              shift and go to state 56
    AND             shift and go to state 57
    OR              shift and go to state 58


state 138

    (39) while_stmt -> WHILE ( expr ) . stmt
    (31) stmt -> . break_stmt
    (32) stmt -> . return_stmt
    (33) stmt -> . while_stmt
    (34) stmt -> . if_stmt
    (35) stmt -> . compound_stmt
    (36) stmt -> . expr_stmt
    (44) break_stmt -> . BREAK
    (42) return_stmt -> . RETURN expr ;
    (43) return_stmt -> . RETURN ;
    (39) while_stmt -> . WHILE ( expr ) stmt
    (40) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (41) if_stmt -> . IF ( expr ) stmt
    (23) compound_stmt -> . { local_decls stmt_list }
    (37) expr_stmt -> . ;
    (38) expr_stmt -> . expr ;
    (47) expr -> . - expr
    (48) expr -> . + expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . CHAR_LIT
    (51) expr -> . FLOAT_LIT
    (52) expr -> . INT_LIT
    (53) expr -> . BOOL_LIT
    (54) expr -> . IDENT . SIZE
    (55) expr -> . IDENT ( args )
    (56) expr -> . CONST
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . ! expr
    (60) expr -> . expr % expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (65) expr -> . expr > expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr < expr
    (68) expr -> . expr LE expr
    (69) expr -> . expr NE expr
    (70) expr -> . expr EQ expr
    (71) expr -> . expr AND expr
    (72) expr -> . expr OR expr
    (73) expr -> . location = expr
    (45) location -> . IDENT [ expr ]
    (46) location -> . IDENT
    BREAK           shift and go to state 118
    RETURN          shift and go to state 119
    WHILE           shift and go to state 122
    IF              shift and go to state 123
    {               shift and go to state 94
    ;               shift and go to state 121
    -               shift and go to state 25
    +               shift and go to state 26
    NEW             shift and go to state 27
    CHAR_LIT        shift and go to state 28
    FLOAT_LIT       shift and go to state 29
    INT_LIT         shift and go to state 30
    BOOL_LIT        shift and go to state 31
    IDENT           shift and go to state 23
    CONST           shift and go to state 22
    (               shift and go to state 32
    !               shift and go to state 34

    expr                           shift and go to state 120
    stmt                           shift and go to state 142
    break_stmt                     shift and go to state 112
    return_stmt                    shift and go to state 113
    while_stmt                     shift and go to state 114
    if_stmt                        shift and go to state 115
    compound_stmt                  shift and go to state 116
    expr_stmt                      shift and go to state 117
    location                       shift and go to state 33

state 139

    (40) if_stmt -> IF ( expr ) . stmt ELSE stmt
    (41) if_stmt -> IF ( expr ) . stmt
    (31) stmt -> . break_stmt
    (32) stmt -> . return_stmt
    (33) stmt -> . while_stmt
    (34) stmt -> . if_stmt
    (35) stmt -> . compound_stmt
    (36) stmt -> . expr_stmt
    (44) break_stmt -> . BREAK
    (42) return_stmt -> . RETURN expr ;
    (43) return_stmt -> . RETURN ;
    (39) while_stmt -> . WHILE ( expr ) stmt
    (40) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (41) if_stmt -> . IF ( expr ) stmt
    (23) compound_stmt -> . { local_decls stmt_list }
    (37) expr_stmt -> . ;
    (38) expr_stmt -> . expr ;
    (47) expr -> . - expr
    (48) expr -> . + expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . CHAR_LIT
    (51) expr -> . FLOAT_LIT
    (52) expr -> . INT_LIT
    (53) expr -> . BOOL_LIT
    (54) expr -> . IDENT . SIZE
    (55) expr -> . IDENT ( args )
    (56) expr -> . CONST
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . ! expr
    (60) expr -> . expr % expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (65) expr -> . expr > expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr < expr
    (68) expr -> . expr LE expr
    (69) expr -> . expr NE expr
    (70) expr -> . expr EQ expr
    (71) expr -> . expr AND expr
    (72) expr -> . expr OR expr
    (73) expr -> . location = expr
    (45) location -> . IDENT [ expr ]
    (46) location -> . IDENT
    BREAK           shift and go to state 118
    RETURN          shift and go to state 119
    WHILE           shift and go to state 122
    IF              shift and go to state 123
    {               shift and go to state 94
    ;               shift and go to state 121
    -               shift and go to state 25
    +               shift and go to state 26
    NEW             shift and go to state 27
    CHAR_LIT        shift and go to state 28
    FLOAT_LIT       shift and go to state 29
    INT_LIT         shift and go to state 30
    BOOL_LIT        shift and go to state 31
    IDENT           shift and go to state 23
    CONST           shift and go to state 22
    (               shift and go to state 32
    !               shift and go to state 34

    expr                           shift and go to state 120
    stmt                           shift and go to state 143
    break_stmt                     shift and go to state 112
    return_stmt                    shift and go to state 113
    while_stmt                     shift and go to state 114
    if_stmt                        shift and go to state 115
    compound_stmt                  shift and go to state 116
    expr_stmt                      shift and go to state 117
    location                       shift and go to state 33

state 140

    (26) local_decl -> type_spec IDENT = expr ; .
    CHAR            reduce using rule 26 (local_decl -> type_spec IDENT = expr ; .)
    BOOL            reduce using rule 26 (local_decl -> type_spec IDENT = expr ; .)
    FLOAT           reduce using rule 26 (local_decl -> type_spec IDENT = expr ; .)
    INT             reduce using rule 26 (local_decl -> type_spec IDENT = expr ; .)
    VOID            reduce using rule 26 (local_decl -> type_spec IDENT = expr ; .)
    }               reduce using rule 26 (local_decl -> type_spec IDENT = expr ; .)
    BREAK           reduce using rule 26 (local_decl -> type_spec IDENT = expr ; .)
    RETURN          reduce using rule 26 (local_decl -> type_spec IDENT = expr ; .)
    WHILE           reduce using rule 26 (local_decl -> type_spec IDENT = expr ; .)
    IF              reduce using rule 26 (local_decl -> type_spec IDENT = expr ; .)
    {               reduce using rule 26 (local_decl -> type_spec IDENT = expr ; .)
    ;               reduce using rule 26 (local_decl -> type_spec IDENT = expr ; .)
    -               reduce using rule 26 (local_decl -> type_spec IDENT = expr ; .)
    +               reduce using rule 26 (local_decl -> type_spec IDENT = expr ; .)
    NEW             reduce using rule 26 (local_decl -> type_spec IDENT = expr ; .)
    CHAR_LIT        reduce using rule 26 (local_decl -> type_spec IDENT = expr ; .)
    FLOAT_LIT       reduce using rule 26 (local_decl -> type_spec IDENT = expr ; .)
    INT_LIT         reduce using rule 26 (local_decl -> type_spec IDENT = expr ; .)
    BOOL_LIT        reduce using rule 26 (local_decl -> type_spec IDENT = expr ; .)
    IDENT           reduce using rule 26 (local_decl -> type_spec IDENT = expr ; .)
    CONST           reduce using rule 26 (local_decl -> type_spec IDENT = expr ; .)
    (               reduce using rule 26 (local_decl -> type_spec IDENT = expr ; .)
    !               reduce using rule 26 (local_decl -> type_spec IDENT = expr ; .)


state 141

    (27) local_decl -> type_spec IDENT [ expr ] . ;
    ;               shift and go to state 144


state 142

    (39) while_stmt -> WHILE ( expr ) stmt .
    }               reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    BREAK           reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    RETURN          reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    WHILE           reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    IF              reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    {               reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    ;               reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    -               reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    +               reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    NEW             reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    CHAR_LIT        reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    FLOAT_LIT       reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    INT_LIT         reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    BOOL_LIT        reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    IDENT           reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    CONST           reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    (               reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    !               reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)
    ELSE            reduce using rule 39 (while_stmt -> WHILE ( expr ) stmt .)


state 143

    (40) if_stmt -> IF ( expr ) stmt . ELSE stmt
    (41) if_stmt -> IF ( expr ) stmt .
    }               reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    BREAK           reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    RETURN          reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    WHILE           reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    IF              reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    {               reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    ;               reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    -               reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    +               reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    NEW             reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    CHAR_LIT        reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    FLOAT_LIT       reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    INT_LIT         reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    BOOL_LIT        reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    IDENT           reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    CONST           reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    (               reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    !               reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)
    ELSE            reduce using rule 41 (if_stmt -> IF ( expr ) stmt .)


state 144

    (27) local_decl -> type_spec IDENT [ expr ] ; .
    CHAR            reduce using rule 27 (local_decl -> type_spec IDENT [ expr ] ; .)
    BOOL            reduce using rule 27 (local_decl -> type_spec IDENT [ expr ] ; .)
    FLOAT           reduce using rule 27 (local_decl -> type_spec IDENT [ expr ] ; .)
    INT             reduce using rule 27 (local_decl -> type_spec IDENT [ expr ] ; .)
    VOID            reduce using rule 27 (local_decl -> type_spec IDENT [ expr ] ; .)
    }               reduce using rule 27 (local_decl -> type_spec IDENT [ expr ] ; .)
    BREAK           reduce using rule 27 (local_decl -> type_spec IDENT [ expr ] ; .)
    RETURN          reduce using rule 27 (local_decl -> type_spec IDENT [ expr ] ; .)
    WHILE           reduce using rule 27 (local_decl -> type_spec IDENT [ expr ] ; .)
    IF              reduce using rule 27 (local_decl -> type_spec IDENT [ expr ] ; .)
    {               reduce using rule 27 (local_decl -> type_spec IDENT [ expr ] ; .)
    ;               reduce using rule 27 (local_decl -> type_spec IDENT [ expr ] ; .)
    -               reduce using rule 27 (local_decl -> type_spec IDENT [ expr ] ; .)
    +               reduce using rule 27 (local_decl -> type_spec IDENT [ expr ] ; .)
    NEW             reduce using rule 27 (local_decl -> type_spec IDENT [ expr ] ; .)
    CHAR_LIT        reduce using rule 27 (local_decl -> type_spec IDENT [ expr ] ; .)
    FLOAT_LIT       reduce using rule 27 (local_decl -> type_spec IDENT [ expr ] ; .)
    INT_LIT         reduce using rule 27 (local_decl -> type_spec IDENT [ expr ] ; .)
    BOOL_LIT        reduce using rule 27 (local_decl -> type_spec IDENT [ expr ] ; .)
    IDENT           reduce using rule 27 (local_decl -> type_spec IDENT [ expr ] ; .)
    CONST           reduce using rule 27 (local_decl -> type_spec IDENT [ expr ] ; .)
    (               reduce using rule 27 (local_decl -> type_spec IDENT [ expr ] ; .)
    !               reduce using rule 27 (local_decl -> type_spec IDENT [ expr ] ; .)


state 145

    (40) if_stmt -> IF ( expr ) stmt ELSE . stmt
    (31) stmt -> . break_stmt
    (32) stmt -> . return_stmt
    (33) stmt -> . while_stmt
    (34) stmt -> . if_stmt
    (35) stmt -> . compound_stmt
    (36) stmt -> . expr_stmt
    (44) break_stmt -> . BREAK
    (42) return_stmt -> . RETURN expr ;
    (43) return_stmt -> . RETURN ;
    (39) while_stmt -> . WHILE ( expr ) stmt
    (40) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (41) if_stmt -> . IF ( expr ) stmt
    (23) compound_stmt -> . { local_decls stmt_list }
    (37) expr_stmt -> . ;
    (38) expr_stmt -> . expr ;
    (47) expr -> . - expr
    (48) expr -> . + expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . CHAR_LIT
    (51) expr -> . FLOAT_LIT
    (52) expr -> . INT_LIT
    (53) expr -> . BOOL_LIT
    (54) expr -> . IDENT . SIZE
    (55) expr -> . IDENT ( args )
    (56) expr -> . CONST
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . ! expr
    (60) expr -> . expr % expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (65) expr -> . expr > expr
    (66) expr -> . expr GE expr
    (67) expr -> . expr < expr
    (68) expr -> . expr LE expr
    (69) expr -> . expr NE expr
    (70) expr -> . expr EQ expr
    (71) expr -> . expr AND expr
    (72) expr -> . expr OR expr
    (73) expr -> . location = expr
    (45) location -> . IDENT [ expr ]
    (46) location -> . IDENT
    BREAK           shift and go to state 118
    RETURN          shift and go to state 119
    WHILE           shift and go to state 122
    IF              shift and go to state 123
    {               shift and go to state 94
    ;               shift and go to state 121
    -               shift and go to state 25
    +               shift and go to state 26
    NEW             shift and go to state 27
    CHAR_LIT        shift and go to state 28
    FLOAT_LIT       shift and go to state 29
    INT_LIT         shift and go to state 30
    BOOL_LIT        shift and go to state 31
    IDENT           shift and go to state 23
    CONST           shift and go to state 22
    (               shift and go to state 32
    !               shift and go to state 34

    expr                           shift and go to state 120
    stmt                           shift and go to state 146
    break_stmt                     shift and go to state 112
    return_stmt                    shift and go to state 113
    while_stmt                     shift and go to state 114
    if_stmt                        shift and go to state 115
    compound_stmt                  shift and go to state 116
    expr_stmt                      shift and go to state 117
    location                       shift and go to state 33

state 146

    (40) if_stmt -> IF ( expr ) stmt ELSE stmt .
    }               reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BREAK           reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    RETURN          reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    WHILE           reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IF              reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    {               reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ;               reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    -               reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    +               reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    NEW             reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    CHAR_LIT        reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FLOAT_LIT       reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    INT_LIT         reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BOOL_LIT        reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IDENT           reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    CONST           reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    (               reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    !               reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ELSE            reduce using rule 40 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
